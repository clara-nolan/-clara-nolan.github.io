{"ast":null,"code":"import{Quaternion}from'three';const calculateCameraRotation=(scrollOffset,rotationTrail)=>{const initialRotationNode=[...rotationTrail].sort((a,b)=>b.offset-a.offset).find(rotationNode=>rotationNode.offset<=scrollOffset);const finalRotationNode=rotationTrail[rotationTrail.findIndex(rotationNode=>(rotationNode==null?void 0:rotationNode.offset)===(initialRotationNode==null?void 0:initialRotationNode.offset))+1];const calculateScrollOffsetRelativeToCurrentRoatationSlerp=(scrollOffset-initialRotationNode.offset)/((finalRotationNode==null?void 0:finalRotationNode.offset)-(initialRotationNode==null?void 0:initialRotationNode.offset));//interpolate camera rotation between nodes in the rotationTrail array\nconst camRotation=new Quaternion().slerpQuaternions(new Quaternion().setFromEuler(initialRotationNode==null?void 0:initialRotationNode.rotation),new Quaternion().setFromEuler(finalRotationNode==null?void 0:finalRotationNode.rotation),calculateScrollOffsetRelativeToCurrentRoatationSlerp);return camRotation;};export default calculateCameraRotation;","map":null,"metadata":{},"sourceType":"module"}