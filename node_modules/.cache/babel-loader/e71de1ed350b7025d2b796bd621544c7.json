{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { strToU8, zipSync } from 'fflate';\nimport { Mesh, MeshPhysicalMaterial } from 'three';\n\nclass USDZExporter {\n  constructor() {\n    _defineProperty(this, \"PRECISION\", 7);\n\n    _defineProperty(this, \"materials\", void 0);\n\n    _defineProperty(this, \"textures\", void 0);\n\n    _defineProperty(this, \"files\", void 0);\n\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n\n  async parse(scene) {\n    const modelFileName = 'model.usda'; // model file should be first in USDZ archive so we init it here\n\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible(object => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd';\n\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split('_')[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(resolve => canvas === null || canvas === void 0 ? void 0 : canvas.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1));\n\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] = new Uint8Array(await blob.arrayBuffer());\n      }\n    } // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\n    let offset = 0;\n\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n\n      if (file && typeof file.length === 'number') {\n        offset = file.length;\n      }\n    }\n\n    return zipSync(this.files, {\n      level: 0\n    });\n  }\n\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext('2d');\n      context === null || context === void 0 ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n\n      if (color !== undefined) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context === null || context === void 0 ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n\n        if (imagedata) {\n          const data = imagedata === null || imagedata === void 0 ? void 0 : imagedata.data;\n\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n\n          context === null || context === void 0 ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n\n      return canvas;\n    }\n  }\n\n  buildHeader() {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`;\n  }\n\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  } // Xform\n\n\n  buildXform(object, geometry, material) {\n    const name = 'Object_' + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n    }\n\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`;\n  }\n\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(array, 8)}, ${this.buildMatrixRow(array, 12)} )`;\n  }\n\n  buildMatrixRow(array, offset) {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n  } // Mesh\n\n\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n  }\n\n  buildMesh(geometry) {\n    const name = 'Geometry';\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n  }\n\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(', ');\n  }\n\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      // @ts-expect-error\n      return geometry.index.array.join(', ');\n    }\n\n    const array = [];\n    const length = geometry.attributes.position.count;\n\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n\n    return array.join(', ');\n  }\n\n  buildVector3Array(attribute, count) {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: Normals missing.');\n      return Array(count).fill('(0, 0, 0)').join(', ');\n    }\n\n    const array = [];\n    const data = attribute.array;\n\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[i + 2].toPrecision(this.PRECISION)})`);\n    }\n\n    return array.join(', ');\n  }\n\n  buildVector2Array(attribute, count) {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: UVs missing.');\n      return Array(count).fill('(0, 0)').join(', ');\n    }\n\n    const array = [];\n    const data = attribute.array;\n\n    for (let i = 0; i < data.length; i += 2) {\n      // @ts-expect-error\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`);\n    }\n\n    return array.join(', ');\n  } // Materials\n\n\n  buildMaterials(materials) {\n    const array = [];\n\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n\n    return `def \"Materials\"\n{\n${array.join('')}\n}\n`;\n  }\n\n  buildMaterial(material) {\n    // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n    const pad = '            ';\n    const inputs = [];\n    const samplers = [];\n\n    if (material.map !== null) {\n      inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.map, 'diffuse', material.color));\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`);\n    }\n\n    if (material.emissiveMap !== null) {\n      inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.emissiveMap, 'emissive'));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`);\n    }\n\n    if (material.normalMap !== null) {\n      inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.normalMap, 'normal'));\n    }\n\n    if (material.aoMap !== null) {\n      inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n      samplers.push(this.buildTexture(material, material.aoMap, 'occlusion'));\n    }\n\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n      samplers.push(this.buildTexture(material, material.roughnessMap, 'roughness'));\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n    }\n\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n      samplers.push(this.buildTexture(material, material.metalnessMap, 'metallic'));\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n    }\n\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n    }\n\n    return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join('\\n')}\n    }\n`;\n  }\n\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? '_' + color.getHexString() : '');\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n      }`;\n  }\n\n  buildColor(color) {\n    return `(${color.r}, ${color.g}, ${color.b})`;\n  }\n\n  buildVector2(vector) {\n    return `(${vector.x}, ${vector.y})`;\n  }\n\n}\n\nexport { USDZExporter };","map":null,"metadata":{},"sourceType":"module"}