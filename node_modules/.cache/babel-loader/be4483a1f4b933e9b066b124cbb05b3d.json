{"ast":null,"code":"import { Vector3, Color, SphericalHarmonics3, LightProbe, LinearEncoding, sRGBEncoding } from 'three';\nvar LightProbeGenerator = {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  fromCubeTexture: function (cubeTexture) {\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var image = cubeTexture.image[faceIndex];\n      var width = image.width;\n      var height = image.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, width, height);\n      var imageData = context.getImageData(0, 0, width, height);\n      var data = imageData.data;\n      var imageWidth = imageData.width; // assumed to be square\n\n      var pixelSize = 2 / imageWidth;\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n\n          case 1:\n            coord.set(1, row, col);\n            break;\n\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  },\n  fromCubeRenderTarget: function (renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var imageWidth = cubeRenderTarget.width; // assumed to be square\n\n      var data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      var pixelSize = 2 / imageWidth;\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n\n          case 1:\n            coord.set(-1, row, col);\n            break;\n\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(col, -1, row);\n            break;\n\n          case 4:\n            coord.set(col, row, 1);\n            break;\n\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  }\n};\n\nvar convertColorToLinear = function (color, encoding) {\n  switch (encoding) {\n    case sRGBEncoding:\n      color.convertSRGBToLinear();\n      break;\n\n    case LinearEncoding:\n      break;\n\n    default:\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');\n      break;\n  }\n\n  return color;\n};\n\nexport { LightProbeGenerator };","map":null,"metadata":{},"sourceType":"module"}