{"ast":null,"code":"import { Loader, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format } from 'three';\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nconst _taskCache = new WeakMap();\n\nclass BasisTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = '';\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.workerConfig = null;\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\n    };\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setWithCredentials(this.withCredentials);\n    const texture = new CompressedTexture();\n    loader.load(url, buffer => {\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n\n      this._createTexture([buffer]).then(function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }).catch(onError);\n    }, onProgress, onError);\n    return texture;\n  }\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n\n\n  parseInternalAsync(options) {\n    const {\n      levels\n    } = options;\n    const buffers = new Set();\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer);\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options,\n      lowLevel: true\n    });\n  }\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n\n\n  _createTexture(buffers) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let worker;\n    let taskID;\n    const taskConfig = config;\n    let taskCost = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength;\n    }\n\n    const texturePending = this._allocateWorker(taskCost).then(_worker => {\n      worker = _worker;\n      taskID = this.workerNextTaskID++;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'transcode',\n          id: taskID,\n          buffers: buffers,\n          taskConfig: taskConfig\n        }, buffers);\n      });\n    }).then(message => {\n      const {\n        mipmaps,\n        width,\n        height,\n        format\n      } = message;\n      const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      return texture;\n    }); // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    texturePending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        worker._taskLoad -= taskCost;\n        delete worker._callbacks[taskID];\n      }\n    }); // Cache the task result.\n\n    _taskCache.set(buffers[0], {\n      promise: texturePending\n    });\n\n    return texturePending;\n  }\n\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject);\n      }); // Load transcoder WASM binary.\n\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType('arraybuffer');\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject);\n      });\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(_ref => {\n        let [jsContent, binaryContent] = _ref;\n        const fn = BasisTextureLoader.BasisWorker.toString();\n        const body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent;\n      });\n    }\n\n    return this.transcoderPending;\n  }\n\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* CONSTANTS */\n\n\nBasisTextureLoader.BasisFormat = {\n  ETC1S: 0,\n  UASTC_4x4: 1\n};\nBasisTextureLoader.TranscoderFormat = {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n};\nBasisTextureLoader.EngineFormat = {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\n};\n/* WEB WORKER */\n\nBasisTextureLoader.BasisWorker = function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n\n  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n\n  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n\n      case 'transcode':\n        transcoderPending.then(() => {\n          try {\n            const {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);\n            const buffers = [];\n\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n\n            self.postMessage({\n              type: 'transcode',\n              id: message.id,\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  };\n\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule); // eslint-disable-line no-undef\n    }).then(() => {\n      BasisModule.initializeBasis();\n    });\n  }\n\n  function transcodeLowLevel(taskConfig) {\n    const {\n      basisFormat,\n      width,\n      height,\n      hasAlpha\n    } = taskConfig;\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.');\n    const mipmaps = [];\n\n    if (basisFormat === BasisFormat.ETC1S) {\n      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n      const {\n        endpointCount,\n        endpointsData,\n        selectorCount,\n        selectorsData,\n        tablesData\n      } = taskConfig.globalData;\n\n      try {\n        let ok;\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n        assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.');\n        ok = transcoder.decodeTables(tablesData);\n        assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.');\n\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i];\n          const imageDesc = taskConfig.globalData.imageDescs[i];\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          const dst = new Uint8Array(dstByteLength);\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n          assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.');\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      } finally {\n        transcoder.delete();\n      }\n    } else {\n      for (let i = 0; i < taskConfig.levels.length; i++) {\n        const level = taskConfig.levels[i];\n        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n        const dst = new Uint8Array(dstByteLength);\n        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n        assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.');\n        mipmaps.push({\n          data: dst,\n          width: level.width,\n          height: level.height\n        });\n      }\n    }\n\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  }\n\n  function transcode(buffer) {\n    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = basisFile.getImageWidth(0, 0);\n    const height = basisFile.getImageHeight(0, 0);\n    const levels = basisFile.getNumLevels(0);\n    const hasAlpha = basisFile.getHasAlpha();\n\n    function cleanup() {\n      basisFile.close();\n      basisFile.delete();\n    }\n\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader:\tInvalid texture');\n    }\n\n    if (!basisFile.startTranscoding()) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader: .startTranscoding failed');\n    }\n\n    const mipmaps = [];\n\n    for (let mip = 0; mip < levels; mip++) {\n      const mipWidth = basisFile.getImageWidth(0, mip);\n      const mipHeight = basisFile.getImageHeight(0, mip);\n      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n\n      if (!status) {\n        cleanup();\n        throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.');\n      }\n\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n\n    cleanup();\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  } //\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\n  // for ETC1S and UASTC.\n  //\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n\n\n  const FORMAT_OPTIONS = [{\n    if: 'astcSupported',\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: 'bptcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: 'dxtSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc2Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc1Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: 'pvrtcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n\n    console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.');\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n\n  function assert(ok, message) {\n    if (!ok) throw new Error(message);\n  }\n\n  function getWidthInBlocks(transcoderFormat, width) {\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n  }\n\n  function getHeightInBlocks(transcoderFormat, height) {\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n  }\n\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n      return width * height * blockByteLength;\n    }\n\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n      // GL requires extra padding for very small textures:\n      // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n      const paddedWidth = width + 3 & ~3;\n      const paddedHeight = height + 3 & ~3;\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n    }\n\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n  }\n\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n};\n\nexport { BasisTextureLoader };","map":null,"metadata":{},"sourceType":"module"}