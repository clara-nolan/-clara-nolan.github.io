{"ast":null,"code":"// eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n// @ts-nocheck\n// Massive respect for Josh Johnston\n// A lot of the logic is taken from his repo -> https://github.com/joshwnj/react-visibility-sensor\n// And is rewritten for hooks api\nimport { useEffect, useReducer } from \"react\";\nimport { useIsomorphicEffect } from \"./useIsomorphicEffect\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\nimport { noop } from \"../utils/noop\";\n\nfunction normalizeRect(rect) {\n  if (rect.width === undefined) {\n    rect.width = rect.right - rect.left;\n  }\n\n  if (rect.height === undefined) {\n    rect.height = rect.bottom - rect.top;\n  }\n\n  return rect;\n}\n\nvar initialState = {\n  isVisible: null,\n  visibilityRect: {}\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"set\":\n      if (state.isVisible === action.payload.isVisible) {\n        return state;\n      }\n\n      return action.payload;\n\n    default:\n      return state;\n  }\n}\n\nvar DEFAULT_OPTIONS = {\n  containment: null,\n  intervalCheck: false,\n  minTopValue: 0,\n  partialVisibility: false,\n  resizeCheck: false,\n  resizeDebounce: 250,\n  resizeThrottle: -1,\n  scrollCheck: true,\n  scrollDebounce: 250,\n  scrollThrottle: -1,\n  shouldCheckOnMount: true\n};\n/**\n * useVisibilitySensor hook\n * Tracks the visibility of a ref\n *\n * @param ref The ref to track visibility of\n * @param opts Options\n * @see {@link https://react-hooks.org/docs/useVisibilitySensor}\n */\n\nfunction useVisibilitySensor(ref, options) {\n  useWarningOnMountInDevelopment(\"useVisibilitySensor is deprecated, it will be removed in rooks v7. Please use useInViewRef instead.\");\n  /*\n      Create local state\n    */\n\n  var _a = useReducer(reducer, initialState),\n      localState = _a[0],\n      dispatch = _a[1];\n  /*\n      Get options\n    */\n\n\n  var _b = Object.assign({}, DEFAULT_OPTIONS, options),\n      containment = _b.containment,\n      intervalCheck = _b.intervalCheck,\n      scrollCheck = _b.scrollCheck,\n      shouldCheckOnMount = _b.shouldCheckOnMount,\n      scrollDebounce = _b.scrollDebounce,\n      scrollThrottle = _b.scrollThrottle,\n      resizeCheck = _b.resizeCheck,\n      resizeDebounce = _b.resizeDebounce,\n      resizeThrottle = _b.resizeThrottle,\n      partialVisibility = _b.partialVisibility,\n      minTopValue = _b.minTopValue;\n\n  function getContainer() {\n    return containment || window;\n  }\n  /*\n      Check visibility\n    */\n\n\n  function checkVisibility() {\n    var containmentRect;\n\n    if (containment) {\n      var containmentDOMRect = containment.getBoundingClientRect();\n      containmentRect = {\n        bottom: containmentDOMRect.bottom,\n        left: containmentDOMRect.left,\n        right: containmentDOMRect.right,\n        top: containmentDOMRect.top\n      };\n    } else {\n      containmentRect = {\n        bottom: window.innerHeight || document.documentElement.clientHeight,\n        left: 0,\n        right: window.innerWidth || document.documentElement.clientWidth,\n        top: 0\n      };\n    }\n\n    var rect = normalizeRect(ref.current.getBoundingClientRect());\n    var hasSize = rect.height > 0 && rect.width > 0;\n    var visibilityRect = {\n      bottom: rect.bottom <= containmentRect.bottom,\n      left: rect.left >= containmentRect.left,\n      right: rect.right <= containmentRect.right,\n      top: rect.top >= containmentRect.top\n    };\n    var isVisible = hasSize && visibilityRect.top && visibilityRect.left && visibilityRect.bottom && visibilityRect.right; // check for partial visibility\n\n    if (hasSize && partialVisibility) {\n      var partialVisible = rect.top <= containmentRect.bottom && rect.bottom >= containmentRect.top && rect.left <= containmentRect.right && rect.right >= containmentRect.left; // account for partial visibility on a single edge\n\n      if (typeof partialVisibility === \"string\") {\n        partialVisible = visibilityRect[partialVisibility];\n      } // if we have minimum top visibility set by props, lets check, if it meets the passed value\n      // so if for instance element is at least 200px in viewport, then show it.\n\n\n      isVisible = minTopValue ? partialVisible && rect.top <= containmentRect.bottom - minTopValue : partialVisible;\n    }\n\n    return {\n      isVisible: isVisible,\n      visibilityRect: visibilityRect\n    };\n  }\n\n  function updateIsVisible() {\n    if (!ref.current) {\n      return;\n    }\n\n    var _a = checkVisibility(),\n        isVisible = _a.isVisible,\n        visibilityRect = _a.visibilityRect;\n\n    dispatch({\n      payload: {\n        isVisible: isVisible,\n        visibilityRect: visibilityRect\n      },\n      type: \"set\"\n    });\n  } // run only once, hence empty array as second argument\n\n\n  useEffect(function () {\n    if (shouldCheckOnMount) {\n      updateIsVisible();\n    }\n  }, []);\n  useEffect(function () {\n    updateIsVisible();\n  }, [ref.current]); // If interval check is needed\n\n  useEffect(function () {\n    if (intervalCheck && intervalCheck > 0) {\n      var intervalTimer_1 = setInterval(function () {\n        updateIsVisible();\n      }, intervalCheck);\n      return function () {\n        clearInterval(intervalTimer_1);\n      };\n    }\n\n    return noop;\n  }, [intervalCheck]);\n\n  function createListener(event, debounce, throttle) {\n    var container = getContainer();\n    var timeout;\n    var listener;\n\n    var later = function () {\n      timeout = null;\n      updateIsVisible();\n    };\n\n    if (throttle > -1) {\n      listener = function () {\n        if (!timeout) {\n          timeout = setTimeout(later, throttle || 0);\n        }\n      };\n    } else {\n      listener = function () {\n        clearTimeout(timeout);\n        timeout = setTimeout(later, debounce || 0);\n      };\n    }\n\n    container.addEventListener(event, listener);\n    return function () {\n      clearTimeout(timeout);\n      container.removeEventListener(event, listener);\n    };\n  } // If scroll check is needed\n\n\n  useIsomorphicEffect(function () {\n    if (scrollCheck) {\n      return createListener(\"scroll\", scrollDebounce, scrollThrottle);\n    }\n\n    return noop;\n  }, []); // if resize check is needed\n\n  useIsomorphicEffect(function () {\n    if (resizeCheck) {\n      return createListener(\"resize\", resizeDebounce, resizeThrottle);\n    }\n\n    return noop;\n  }, []);\n  return localState;\n}\n\nexport { useVisibilitySensor };","map":null,"metadata":{},"sourceType":"module"}