{"ast":null,"code":"import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\n\nconst col = new THREE.Color();\n\nfunction Container(_ref) {\n  let {\n    canvasSize,\n    scene,\n    index,\n    children,\n    frames,\n    rect,\n    track\n  } = _ref;\n  const get = useThree(state => state.get);\n  const camera = useThree(state => state.camera);\n  const virtualScene = useThree(state => state.scene);\n  const setEvents = useThree(state => state.setEvents);\n  let frameCount = 0;\n  useFrame(state => {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n\n      rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n\n    if (rect.current) {\n      const {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height\n      } = rect.current;\n      const isOffscreen = bottom < 0 || top > canvasSize.height || right < 0 || left > canvasSize.width;\n      const positiveYUpBottom = canvasSize.height - bottom;\n      const aspect = width / height;\n\n      if (isOrthographicCamera(camera)) {\n        if (camera.left !== width / -2 || camera.right !== width / 2 || camera.top !== height / 2 || camera.bottom !== height / -2) {\n          Object.assign(camera, {\n            left: width / -2,\n            right: width / 2,\n            top: height / 2,\n            bottom: height / -2\n          });\n          camera.updateProjectionMatrix();\n        }\n      } else if (camera.aspect !== aspect) {\n        camera.aspect = aspect;\n        camera.updateProjectionMatrix();\n      }\n\n      state.gl.setViewport(left, positiveYUpBottom, width, height);\n      state.gl.setScissor(left, positiveYUpBottom, width, height);\n      state.gl.setScissorTest(true);\n\n      if (isOffscreen) {\n        state.gl.getClearColor(col);\n        state.gl.setClearColor(col, state.gl.getClearAlpha());\n        state.gl.clear(true, true);\n        return;\n      } // When children are present render the portalled scene, otherwise the default scene\n\n\n      state.gl.render(children ? virtualScene : scene, camera);\n    }\n  }, index);\n  React.useEffect(() => {\n    // Connect the event layer to the tracking element\n    const old = get().events.connected;\n    setEvents({\n      connected: track.current\n    });\n    return () => setEvents({\n      connected: old\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nconst View = _ref2 => {\n  let {\n    track,\n    index = 1,\n    frames = Infinity,\n    children\n  } = _ref2;\n  const rect = React.useRef(null);\n  const {\n    size,\n    scene\n  } = useThree();\n  const [virtualScene] = React.useState(() => new THREE.Scene());\n  const compute = React.useCallback((event, state) => {\n    if (track.current && event.target === track.current) {\n      const {\n        width,\n        height,\n        left,\n        top\n      } = rect.current;\n      const x = event.clientX - left;\n      const y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect]);\n  const [ready, toggle] = React.useReducer(() => true, false);\n  React.useEffect(() => {\n    var _track$current2; // We need the tracking elements bounds beforehand in order to inject it into the portal\n\n\n    rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect(); // And now we can proceed\n\n    toggle();\n  }, []);\n  return ready && createPortal( /*#__PURE__*/React.createElement(Container, {\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute,\n      priority: index\n    },\n    size: {\n      width: rect.current.width,\n      height: rect.current.height\n    }\n  });\n};\n\nexport { View };","map":null,"metadata":{},"sourceType":"module"}