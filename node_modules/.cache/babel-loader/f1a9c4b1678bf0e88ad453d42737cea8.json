{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\clara\\\\Documents\\\\personalSite\\\\clara-nolan.github.io\\\\src\\\\3d-components\\\\track\\\\index.js\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { useScroll } from '@react-three/drei';\nimport useStore from '../../context/mainStore';\nimport pathCurve, { rotationTrail } from './pathCurve';\nimport calculateCameraRotation from '../../utils/calcualteCameraRotation'; //TODO: Instead of getting the reference of the camera and calculating it's position/rotation here,\n//get the referance of the track and calculate position/rotation inside of the camera component\n//I forgot how this works, touch at your own risk. If anyone has a good way to implement smooth stop points in the track please let me know\n\nconst SLOWDOWN_FACTOR = 7; // the lower the slower it goes\n\nconst STOP_POINTS = [0.114, 0.211, 0.3015, 0.412, 0.5143, 0.625]; // they have to be separated by one SMOOTH_AMOUNT unit for example if smooth amount is 0.1 and the first stop point is 0.1 the second o stop_point has to be > 0.2\n\nconst SMOOTH_AMOUNT = 0.1; // how much time the smooth takes\n\nfunction Knot() {\n  _s();\n\n  const [translateToCamera, setTranslateToCamera] = useState(true);\n  const tubeGeometry = useRef();\n  const scroll = useScroll();\n  const {\n    setIsNavVisible,\n    isNavVisible,\n    cameraRef,\n    floatingCamera,\n    setScrollElement\n  } = useStore(state => state);\n  useEffect(() => {\n    setTimeout(() => setTranslateToCamera(false), 1900);\n  }, []);\n  useEffect(() => {\n    if (scroll.el) {\n      setScrollElement(scroll.el);\n    }\n  }, [scroll.el, setScrollElement]);\n  useEffect(() => {\n    if (floatingCamera) setTranslateToCamera(true);else setTimeout(() => setTranslateToCamera(false), 1200);\n  }, [floatingCamera]);\n  let prevOffset = scroll.offset;\n  useFrame(() => {\n    //Set the visibility of the nav bar (Maby not the best place to do it but...)\n    if (prevOffset > scroll.offset && !isNavVisible) {\n      setIsNavVisible(true);\n    }\n\n    if (prevOffset < scroll.offset && isNavVisible) {\n      setIsNavVisible(false);\n    }\n\n    prevOffset = scroll.offset; //This took me a week to nail down.\n\n    const totalSmooth = STOP_POINTS.reduce((prev, current) => {\n      const smoothRange = scroll.range(current, SMOOTH_AMOUNT);\n      const smoothCurve = scroll.curve(current, SMOOTH_AMOUNT);\n      return prev + smoothRange / (10 + SLOWDOWN_FACTOR * (1 - smoothCurve / 1.3));\n    }, 0);\n    const calculatedCurrentScroll = ((scroll == null ? void 0 : scroll.offset) - totalSmooth) / (1 - 1 / (10 + SLOWDOWN_FACTOR) * STOP_POINTS.length);\n    const currentScroll = calculatedCurrentScroll > 0.9999999 ? 0.999999 : calculatedCurrentScroll;\n\n    if (tubeGeometry.current && cameraRef) {\n      const {\n        path: tubePath\n      } = tubeGeometry.current.parameters;\n      const currentPosition = tubePath == null ? void 0 : tubePath.getPointAt(currentScroll); //set camera rotation\n\n      if (!floatingCamera) {\n        cameraRef.setRotationFromQuaternion(calculateCameraRotation(currentScroll, rotationTrail)); //set camera position\n\n        if (translateToCamera) {\n          cameraRef.translateOnAxis(cameraRef.worldToLocal(currentPosition), 0.1);\n        } else {\n          cameraRef.position.set(currentPosition.x, currentPosition.y, currentPosition.z);\n        }\n      }\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"mesh\", {\n    scale: [1, 1, 1],\n    position: [0, 0, 0],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    visible: false,\n    color: \"transparent\",\n    wireframe: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"tubeBufferGeometry\", {\n    ref: tubeGeometry,\n    args: [pathCurve, 202, 3, 5, false],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 7\n    }\n  }));\n}\n\n_s(Knot, \"v+Qt45yBvqOCtY7gzlorA0Ve7JY=\", false, function () {\n  return [useScroll, useStore, useFrame];\n});\n\n_c = Knot;\n\nconst Track = () => {\n  return /*#__PURE__*/React.createElement(Knot, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 10\n    }\n  });\n};\n\n_c2 = Track;\nexport default Track;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Knot\");\n$RefreshReg$(_c2, \"Track\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useFrame","useScroll","useStore","pathCurve","rotationTrail","calculateCameraRotation","SLOWDOWN_FACTOR","STOP_POINTS","SMOOTH_AMOUNT","Knot","translateToCamera","setTranslateToCamera","tubeGeometry","scroll","setIsNavVisible","isNavVisible","cameraRef","floatingCamera","setScrollElement","state","setTimeout","el","prevOffset","offset","totalSmooth","reduce","prev","current","smoothRange","range","smoothCurve","curve","calculatedCurrentScroll","length","currentScroll","path","tubePath","parameters","currentPosition","getPointAt","setRotationFromQuaternion","translateOnAxis","worldToLocal","position","set","x","y","z","Track"],"sources":["C:/Users/clara/Documents/personalSite/clara-nolan.github.io/src/3d-components/track/index.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { useScroll } from '@react-three/drei';\r\n\r\nimport useStore from '../../context/mainStore';\r\nimport pathCurve, { rotationTrail } from './pathCurve';\r\nimport calculateCameraRotation from '../../utils/calcualteCameraRotation';\r\n\r\n//TODO: Instead of getting the reference of the camera and calculating it's position/rotation here,\r\n//get the referance of the track and calculate position/rotation inside of the camera component\r\n\r\n//I forgot how this works, touch at your own risk. If anyone has a good way to implement smooth stop points in the track please let me know\r\n\r\nconst SLOWDOWN_FACTOR = 7; // the lower the slower it goes\r\nconst STOP_POINTS = [0.114, 0.211, 0.3015, 0.412, 0.5143, 0.625]; // they have to be separated by one SMOOTH_AMOUNT unit for example if smooth amount is 0.1 and the first stop point is 0.1 the second o stop_point has to be > 0.2\r\nconst SMOOTH_AMOUNT = 0.1; // how much time the smooth takes\r\n\r\nfunction Knot() {\r\n  const [translateToCamera, setTranslateToCamera] = useState(true);\r\n  const tubeGeometry = useRef();\r\n  const scroll = useScroll();\r\n  const {\r\n    setIsNavVisible,\r\n    isNavVisible,\r\n    cameraRef,\r\n    floatingCamera,\r\n    setScrollElement,\r\n  } = useStore((state) => state);\r\n\r\n  useEffect(() => {\r\n    setTimeout(() => setTranslateToCamera(false), 1900);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (scroll.el) {\r\n      setScrollElement(scroll.el);\r\n    }\r\n  }, [scroll.el, setScrollElement]);\r\n\r\n  useEffect(() => {\r\n    if (floatingCamera) setTranslateToCamera(true);\r\n    else setTimeout(() => setTranslateToCamera(false), 1200);\r\n  }, [floatingCamera]);\r\n\r\n  let prevOffset = scroll.offset;\r\n\r\n  useFrame(() => {\r\n    //Set the visibility of the nav bar (Maby not the best place to do it but...)\r\n    if (prevOffset > scroll.offset && !isNavVisible) {\r\n      setIsNavVisible(true);\r\n    }\r\n    if (prevOffset < scroll.offset && isNavVisible) {\r\n      setIsNavVisible(false);\r\n    }\r\n\r\n    prevOffset = scroll.offset;\r\n    //This took me a week to nail down.\r\n    const totalSmooth = STOP_POINTS.reduce((prev, current) => {\r\n      const smoothRange = scroll.range(current, SMOOTH_AMOUNT);\r\n      const smoothCurve = scroll.curve(current, SMOOTH_AMOUNT);\r\n\r\n      return (\r\n        prev + smoothRange / (10 + SLOWDOWN_FACTOR * (1 - smoothCurve / 1.3))\r\n      );\r\n    }, 0);\r\n\r\n    const calculatedCurrentScroll =\r\n      (scroll?.offset - totalSmooth) /\r\n      (1 - (1 / (10 + SLOWDOWN_FACTOR)) * STOP_POINTS.length);\r\n\r\n    const currentScroll =\r\n      calculatedCurrentScroll > 0.9999999 ? 0.999999 : calculatedCurrentScroll;\r\n\r\n    if (tubeGeometry.current && cameraRef) {\r\n      const { path: tubePath } = tubeGeometry.current.parameters;\r\n      const currentPosition = tubePath?.getPointAt(currentScroll);\r\n\r\n      //set camera rotation\r\n      if (!floatingCamera) {\r\n        cameraRef.setRotationFromQuaternion(\r\n          calculateCameraRotation(currentScroll, rotationTrail)\r\n        );\r\n\r\n        //set camera position\r\n        if (translateToCamera) {\r\n          cameraRef.translateOnAxis(\r\n            cameraRef.worldToLocal(currentPosition),\r\n            0.1\r\n          );\r\n        } else {\r\n          cameraRef.position.set(\r\n            currentPosition.x,\r\n            currentPosition.y,\r\n            currentPosition.z\r\n          );\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <mesh scale={[1, 1, 1]} position={[0, 0, 0]}>\r\n      <meshBasicMaterial visible={false} color='transparent' wireframe />\r\n      <tubeBufferGeometry\r\n        ref={tubeGeometry}\r\n        args={[pathCurve, 202, 3, 5, false]}\r\n      />\r\n    </mesh>\r\n  );\r\n}\r\n\r\nconst Track = () => {\r\n  return <Knot />;\r\n};\r\n\r\nexport default Track;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}