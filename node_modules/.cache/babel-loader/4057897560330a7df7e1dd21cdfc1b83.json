{"ast":null,"code":"import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = ['x', 'y', 'z'];\nexport function raycast(nodeIndex32, geometry, side, ray, intersects) {\n  let nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    intersectTris(geometry, side, ray, offset, count, intersects);\n  } else {\n    const leftIndex = LEFT_NODE(nodeIndex32);\n\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\n      raycast(leftIndex, geometry, side, ray, intersects);\n    }\n\n    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);\n\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\n      raycast(rightIndex, geometry, side, ray, intersects);\n    }\n  }\n}\nexport function raycastFirst(nodeIndex32, geometry, side, ray) {\n  let nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    return intersectClosestTri(geometry, side, ray, offset, count);\n  } else {\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\n    // the ray is coming from, look for an intersection among that side of the tree first\n    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n    const xyzAxis = xyzFields[splitAxis];\n    const rayDir = ray.direction[xyzAxis];\n    const leftToRight = rayDir >= 0; // c1 is the child to check first\n\n    let c1, c2;\n\n    if (leftToRight) {\n      c1 = LEFT_NODE(nodeIndex32);\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\n    } else {\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\n      c2 = LEFT_NODE(nodeIndex32);\n    }\n\n    const c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\n    const c1Result = c1Intersection ? raycastFirst(c1, geometry, side, ray) : null; // if we got an intersection in the first node and it's closer than the second node's bounding\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\n\n    if (c1Result) {\n      // check if the point is within the second bounds\n      // \"point\" is in the local frame of the bvh\n      const point = c1Result.point[xyzAxis];\n      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : // min bounding data\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n\n      if (isOutside) {\n        return c1Result;\n      }\n    } // either there was no intersection in the first node, or there could still be a closer\n    // intersection in the second, so check the second node and then take the better of the two\n\n\n    const c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\n    const c2Result = c2Intersection ? raycastFirst(c2, geometry, side, ray) : null;\n\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\nexport const shapecast = function () {\n  let _box1, _box2;\n\n  const boxStack = [];\n  const boxPool = new PrimitivePool(() => new Box3());\n  return function shapecast() {\n    _box1 = boxPool.getPrimitive();\n    _box2 = boxPool.getPrimitive();\n    boxStack.push(_box1, _box2);\n    const result = shapecastTraverse(...arguments);\n    boxPool.releasePrimitive(_box1);\n    boxPool.releasePrimitive(_box2);\n    boxStack.pop();\n    boxStack.pop();\n    const length = boxStack.length;\n\n    if (length > 0) {\n      _box2 = boxStack[length - 1];\n      _box1 = boxStack[length - 2];\n    }\n\n    return result;\n  };\n\n  function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\n    let nodeScoreFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    let depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    function getLeftOffset(nodeIndex32) {\n      let nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      return OFFSET(nodeIndex32, uint32Array);\n    }\n\n    function getRightEndOffset(nodeIndex32) {\n      let nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      } // return the end offset of the triangle range\n\n\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    }\n\n    let nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n    if (isLeaf) {\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const count = COUNT(nodeIndex16, uint16Array);\n      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n    } else {\n      const left = LEFT_NODE(nodeIndex32);\n      const right = RIGHT_NODE(nodeIndex32, uint32Array);\n      let c1 = left;\n      let c2 = right;\n      let score1, score2;\n      let box1, box2;\n\n      if (nodeScoreFunc) {\n        box1 = _box1;\n        box2 = _box2; // bounding data is not offset\n\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n        arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n        score1 = nodeScoreFunc(box1);\n        score2 = nodeScoreFunc(box2);\n\n        if (score2 < score1) {\n          c1 = right;\n          c2 = left;\n          const temp = score1;\n          score1 = score2;\n          score2 = temp;\n          box1 = box2; // box2 is always set before use below\n        }\n      } // Check box 1 intersection\n\n\n      if (!box1) {\n        box1 = _box1;\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      }\n\n      const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n      const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n      let c1StopTraversal;\n\n      if (c1Intersection === CONTAINED) {\n        const offset = getLeftOffset(c1);\n        const end = getRightEndOffset(c1);\n        const count = end - offset;\n        c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n      } else {\n        c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n\n      if (c1StopTraversal) return true; // Check box 2 intersection\n      // cached box2 will have been overwritten by previous traversal\n\n      box2 = _box2;\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n      const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n      let c2StopTraversal;\n\n      if (c2Intersection === CONTAINED) {\n        const offset = getLeftOffset(c2);\n        const end = getRightEndOffset(c2);\n        const count = end - offset;\n        c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n      } else {\n        c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n\n      if (c2StopTraversal) return true;\n      return false;\n    }\n  }\n}();\nexport const intersectsGeometry = function () {\n  const triangle = new ExtendedTriangle();\n  const triangle2 = new ExtendedTriangle();\n  const invertedMat = new Matrix4();\n  const obb = new OrientedBox();\n  const obb2 = new OrientedBox();\n  return function intersectsGeometry(nodeIndex32, geometry, otherGeometry, geometryToBvh) {\n    let cachedObb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n    if (cachedObb === null) {\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      cachedObb = obb;\n    }\n\n    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n    if (isLeaf) {\n      const thisGeometry = geometry;\n      const thisIndex = thisGeometry.index;\n      const thisPos = thisGeometry.attributes.position;\n      const index = otherGeometry.index;\n      const pos = otherGeometry.attributes.position;\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const count = COUNT(nodeIndex16, uint16Array); // get the inverse of the geometry matrix so we can transform our triangles into the\n      // geometry space we're trying to test. We assume there are fewer triangles being checked\n      // here.\n\n      invertedMat.copy(geometryToBvh).invert();\n\n      if (otherGeometry.boundsTree) {\n        arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\n        obb2.matrix.copy(invertedMat);\n        obb2.needsUpdate = true;\n        const res = otherGeometry.boundsTree.shapecast({\n          intersectsBounds: box => obb2.intersectsBox(box),\n          intersectsTriangle: tri => {\n            tri.a.applyMatrix4(geometryToBvh);\n            tri.b.applyMatrix4(geometryToBvh);\n            tri.c.applyMatrix4(geometryToBvh);\n            tri.needsUpdate = true;\n\n            for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n              // this triangle needs to be transformed into the current BVH coordinate frame\n              setTriangle(triangle2, i, thisIndex, thisPos);\n              triangle2.needsUpdate = true;\n\n              if (tri.intersectsTriangle(triangle2)) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        });\n        return res;\n      } else {\n        for (let i = offset * 3, l = count + offset * 3; i < l; i += 3) {\n          // this triangle needs to be transformed into the current BVH coordinate frame\n          setTriangle(triangle, i, thisIndex, thisPos);\n          triangle.a.applyMatrix4(invertedMat);\n          triangle.b.applyMatrix4(invertedMat);\n          triangle.c.applyMatrix4(invertedMat);\n          triangle.needsUpdate = true;\n\n          for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, index, pos);\n            triangle2.needsUpdate = true;\n\n            if (triangle.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      const left = nodeIndex32 + 8;\n      const right = uint32Array[nodeIndex32 + 6];\n      arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\n      const leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(left, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (leftIntersection) return true;\n      arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\n      const rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(right, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (rightIntersection) return true;\n      return false;\n    }\n  };\n}();\n\nfunction intersectRay(nodeIndex32, array, ray, target) {\n  arrayToBox(nodeIndex32, array, boundingBox);\n  return ray.intersectBox(boundingBox, target);\n}\n\nconst bufferStack = [];\n\nlet _prevBuffer;\n\nlet _float32Array;\n\nlet _uint16Array;\n\nlet _uint32Array;\n\nexport function setBuffer(buffer) {\n  if (_prevBuffer) {\n    bufferStack.push(_prevBuffer);\n  }\n\n  _prevBuffer = buffer;\n  _float32Array = new Float32Array(buffer);\n  _uint16Array = new Uint16Array(buffer);\n  _uint32Array = new Uint32Array(buffer);\n}\nexport function clearBuffer() {\n  _prevBuffer = null;\n  _float32Array = null;\n  _uint16Array = null;\n  _uint32Array = null;\n\n  if (bufferStack.length) {\n    setBuffer(bufferStack.pop());\n  }\n}","map":null,"metadata":{},"sourceType":"module"}