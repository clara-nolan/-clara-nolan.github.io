{"ast":null,"code":"// See also: https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nimport { useState, useEffect, useRef } from \"react\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\nimport { noop } from \"../utils/noop\";\n/**\n *\n * useInterval hook\n *\n * Declaratively creates a setInterval to run a callback after a fixed\n * amount of time\n *\n *@param {Function} callback - Callback to be fired\n *@param {number} intervalId - Interval duration in milliseconds after which the callback is to be fired\n *@param {boolean} startImmediate - Whether the interval should start immediately on initialise\n *@returns {IntervalHandler}\n */\n\nfunction useInterval(callback, intervalDuration, startImmediate) {\n  if (startImmediate === void 0) {\n    startImmediate = false;\n  }\n\n  useWarningOnMountInDevelopment(\"useInterval is deprecated, it will be removed in rooks v7. Please use useIntervalWhen instead.\");\n  var internalIdRef = useRef(null);\n\n  var _a = useState(startImmediate),\n      isRunning = _a[0],\n      setIsRunning = _a[1];\n\n  var savedCallback = useRef();\n\n  function start() {\n    if (!isRunning) {\n      setIsRunning(true);\n    }\n  }\n\n  function stop() {\n    if (isRunning) {\n      setIsRunning(false);\n    }\n  } // Remember the latest callback.\n\n\n  useEffect(function () {\n    savedCallback.current = callback;\n  }); // Set up the interval.\n\n  useEffect(function () {\n    function tick() {\n      var _a;\n\n      (_a = savedCallback.current) === null || _a === void 0 ? void 0 : _a.call(savedCallback);\n    }\n\n    if (intervalDuration !== null && isRunning) {\n      var id_1 = setInterval(tick, intervalDuration);\n      internalIdRef.current = id_1;\n      return function () {\n        internalIdRef.current = null;\n        clearInterval(id_1);\n      };\n    }\n\n    return noop;\n  }, [intervalDuration, isRunning]);\n  var handler;\n  handler = [start, stop, internalIdRef.current];\n  handler.start = start;\n  handler.stop = stop;\n  handler.intervalId = internalIdRef.current;\n  return handler;\n}\n\nexport { useInterval };","map":null,"metadata":{},"sourceType":"module"}