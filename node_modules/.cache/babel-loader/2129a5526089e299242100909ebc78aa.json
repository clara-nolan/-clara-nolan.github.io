{"ast":null,"code":"import { noop } from \"../utils/noop\";\nimport { useEffect, useCallback, useState } from \"react\";\nvar config = {\n  root: null,\n  rootMargin: \"0px 0px 0px 0px\",\n  threshold: [0, 1]\n};\n/**\n *\n * useInViewRef hook\n *\n * Returns a mutation observer for a React Ref and true/false when element enters/leaves the viewport. Also fires a callback.\n *\n * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation\n * @param {IntersectionObserverInit} options\n */\n\nfunction useInViewRef(callback, options) {\n  if (callback === void 0) {\n    callback = function () {};\n  }\n\n  if (options === void 0) {\n    options = config;\n  }\n\n  var _a = options.root,\n      root = _a === void 0 ? null : _a,\n      rootMargin = options.rootMargin,\n      threshold = options.threshold;\n\n  var _b = useState(null),\n      node = _b[0],\n      setNode = _b[1];\n\n  var _c = useState(false),\n      inView = _c[0],\n      setInView = _c[1];\n\n  useEffect(function () {\n    // Create an observer instance linked to the callback function\n    if (node) {\n      var observer_1 = new IntersectionObserver(function (entries, observerRef) {\n        entries.forEach(function (_a) {\n          var isIntersecting = _a.isIntersecting;\n          return setInView(isIntersecting);\n        });\n        callback(entries, observerRef);\n      }, options); // Start observing the target node for configured mutations\n\n      observer_1.observe(node);\n      return function () {\n        observer_1.disconnect();\n      };\n    }\n\n    return noop;\n  }, [node, callback, root, rootMargin, threshold]);\n  var ref = useCallback(function (node) {\n    setNode(node);\n  }, []);\n  return [ref, inView];\n}\n\nexport { useInViewRef };","map":null,"metadata":{},"sourceType":"module"}