{"ast":null,"code":"import TempNode from '../core/TempNode.js';\n\nclass OperatorNode extends TempNode {\n  constructor(op, aNode, bNode) {\n    super();\n    this.op = op;\n\n    if ((arguments.length <= 3 ? 0 : arguments.length - 3) > 0) {\n      let finalBNode = bNode;\n\n      for (let i = 0; i < (arguments.length <= 3 ? 0 : arguments.length - 3); i++) {\n        finalBNode = new OperatorNode(op, finalBNode, i + 3 < 3 || arguments.length <= i + 3 ? undefined : arguments[i + 3]);\n      }\n\n      bNode = finalBNode;\n    }\n\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = bNode.getNodeType(builder);\n\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '=' || op === '%') {\n      return typeA;\n    } else if (op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return 'int';\n    } else if (op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = builder.getTypeLength(output);\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n        return typeB;\n      }\n\n      return typeA;\n    }\n  }\n\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = bNode.getNodeType(builder);\n\n      if (op === '=') {\n        typeB = typeA;\n      } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else {\n          typeA = typeB = 'float';\n        }\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n\n    const a = aNode.build(builder, typeA);\n    const b = bNode.build(builder, typeB);\n    const outputLength = builder.getTypeLength(output);\n\n    if (output !== 'void') {\n      if (op === '=') {\n        builder.addFlowCode(`${a} ${this.op} ${b}`);\n        return a;\n      } else if (op === '>' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('greaterThan')}( ${a}, ${b} )`, type, output);\n      } else if (op === '<=' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('lessThanEqual')}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      return builder.format(`${a} ${this.op} ${b}`, type, output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n\n}\n\nexport default OperatorNode;","map":null,"metadata":{},"sourceType":"module"}