{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ErrorHandler = void 0;\n\nvar exceptions_public_1 = require(\"../../exceptions_public\");\n\nvar has_1 = __importDefault(require(\"lodash/has\"));\n\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\n\nvar lookahead_1 = require(\"../../grammar/lookahead\");\n\nvar parser_1 = require(\"../parser\");\n/**\n * Trait responsible for runtime parsing errors.\n */\n\n\nvar ErrorHandler =\n/** @class */\nfunction () {\n  function ErrorHandler() {}\n\n  ErrorHandler.prototype.initErrorHandler = function (config) {\n    this._errors = [];\n    this.errorMessageProvider = (0, has_1.default)(config, \"errorMessageProvider\") ? config.errorMessageProvider // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  };\n\n  ErrorHandler.prototype.SAVE_ERROR = function (error) {\n    if ((0, exceptions_public_1.isRecognitionException)(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)\n      };\n\n      this._errors.push(error);\n\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  };\n\n  Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n    get: function () {\n      return (0, clone_1.default)(this._errors);\n    },\n    set: function (newErrors) {\n      this._errors = newErrors;\n    },\n    enumerable: false,\n    configurable: true\n  }); // TODO: consider caching the error message computed information\n\n  ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    var insideProdPaths = lookAheadPathsPerAlternative[0];\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }; // TODO: consider caching the error message computed information\n\n\n  ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName]; // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n\n    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var previousToken = this.LA(0);\n    var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));\n  };\n\n  return ErrorHandler;\n}();\n\nexports.ErrorHandler = ErrorHandler; //# sourceMappingURL=error_handler.js.map","map":null,"metadata":{},"sourceType":"script"}