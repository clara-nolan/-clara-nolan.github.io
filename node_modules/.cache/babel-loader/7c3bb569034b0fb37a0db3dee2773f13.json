{"ast":null,"code":"import { Color, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, LinearFilter, RGBAFormat, HalfFloatType, ShaderMaterial, UniformsUtils, NoBlending, MeshNormalMaterial, MeshBasicMaterial, SrcAlphaFactor, OneMinusSrcAlphaFactor, AddEquation, NormalBlending } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { SSRShader, SSRBlurShader, SSRDepthShader } from '../shaders/SSRShader.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nvar SSRPass = function (_ref) {\n  let {\n    renderer,\n    scene,\n    camera,\n    width,\n    height,\n    selects,\n    encoding,\n    isPerspectiveCamera = true,\n    isBouncing = false,\n    morphTargets = false,\n    groundReflector\n  } = _ref;\n  this.width = width !== undefined ? width : 512;\n  this.height = height !== undefined ? height : 512;\n  this.clear = true;\n  this.renderer = renderer;\n  this.scene = scene;\n  this.camera = camera;\n  this.groundReflector = groundReflector;\n  this.opacity = SSRShader.uniforms.opacity.value;\n  this.output = 0;\n  this.maxDistance = SSRShader.uniforms.maxDistance.value;\n  this.surfDist = SSRShader.uniforms.surfDist.value;\n  this.encoding = encoding;\n  this.tempColor = new Color();\n  this._selects = selects;\n  this.isSelective = Array.isArray(this._selects);\n  Object.defineProperty(this, 'selects', {\n    get() {\n      return this._selects;\n    },\n\n    set(val) {\n      if (this._selects === val) return;\n      this._selects = val;\n\n      if (Array.isArray(val)) {\n        this.isSelective = true;\n        this.ssrMaterial.defines.isSelective = true;\n        this.ssrMaterial.needsUpdate = true;\n      } else {\n        this.isSelective = false;\n        this.ssrMaterial.defines.isSelective = false;\n        this.ssrMaterial.needsUpdate = true;\n      }\n    }\n\n  });\n  this._isBouncing = isBouncing; ///todo: don't need defineProperty\n\n  Object.defineProperty(this, 'isBouncing', {\n    get() {\n      return this._isBouncing;\n    },\n\n    set(val) {\n      if (this._isBouncing === val) return;\n      this._isBouncing = val;\n\n      if (val) {\n        this.ssrMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture;\n      } else {\n        this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n      }\n    }\n\n  });\n  this.isBlur = true;\n  this._isDistanceAttenuation = SSRShader.defines.isDistanceAttenuation;\n  Object.defineProperty(this, 'isDistanceAttenuation', {\n    get() {\n      return this._isDistanceAttenuation;\n    },\n\n    set(val) {\n      if (this._isDistanceAttenuation === val) return;\n      this._isDistanceAttenuation = val;\n      this.ssrMaterial.defines.isDistanceAttenuation = val;\n      this.ssrMaterial.needsUpdate = true;\n    }\n\n  });\n  this._isFresnel = SSRShader.defines.isFresnel;\n  Object.defineProperty(this, 'isFresnel', {\n    get() {\n      return this._isFresnel;\n    },\n\n    set(val) {\n      if (this._isFresnel === val) return;\n      this._isFresnel = val;\n      this.ssrMaterial.defines.isFresnel = val;\n      this.ssrMaterial.needsUpdate = true;\n    }\n\n  });\n  this._isInfiniteThick = SSRShader.defines.isInfiniteThick;\n  Object.defineProperty(this, 'isInfiniteThick', {\n    get() {\n      return this._isInfiniteThick;\n    },\n\n    set(val) {\n      if (this._isInfiniteThick === val) return;\n      this._isInfiniteThick = val;\n      this.ssrMaterial.defines.isInfiniteThick = val;\n      this.ssrMaterial.needsUpdate = true;\n    }\n\n  });\n  this.thickTolerance = SSRShader.uniforms.thickTolerance.value; // beauty render target with depth buffer\n\n  var depthTexture = new DepthTexture();\n  depthTexture.type = UnsignedShortType;\n  depthTexture.minFilter = NearestFilter;\n  depthTexture.maxFilter = NearestFilter;\n  this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat,\n    depthTexture: depthTexture,\n    depthBuffer: true\n  }); //for bouncing\n\n  this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  }); // normal render target\n\n  this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: NearestFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat,\n    type: HalfFloatType\n  }); // metalness render target\n  // if (this.isSelective) {\n\n  this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: NearestFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  }); // }\n  // ssr render target\n\n  this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  });\n  this.blurRenderTarget = this.ssrRenderTarget.clone();\n  this.blurRenderTarget2 = this.ssrRenderTarget.clone(); // this.blurRenderTarget3 = this.ssrRenderTarget.clone();\n  // ssr material\n\n  if (SSRShader === undefined) {\n    console.error('THREE.SSRPass: The pass relies on SSRShader.');\n  }\n\n  this.ssrMaterial = new ShaderMaterial({\n    defines: Object.assign({\n      MAX_STEP: Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight)\n    }, SSRShader.defines),\n    uniforms: UniformsUtils.clone(SSRShader.uniforms),\n    vertexShader: SSRShader.vertexShader,\n    fragmentShader: SSRShader.fragmentShader,\n    blending: NoBlending\n  });\n\n  if (!isPerspectiveCamera) {\n    this.ssrMaterial.defines.isPerspectiveCamera = isPerspectiveCamera;\n    this.ssrMaterial.needsUpdate = true;\n  }\n\n  this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n  this.ssrMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture; // if (this.isSelective) {\n\n  this.ssrMaterial.defines.isSelective = this.isSelective;\n  this.ssrMaterial.needsUpdate = true;\n  this.ssrMaterial.uniforms['tMetalness'].value = this.metalnessRenderTarget.texture; // }\n\n  this.ssrMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture;\n  this.ssrMaterial.uniforms['cameraNear'].value = this.camera.near;\n  this.ssrMaterial.uniforms['cameraFar'].value = this.camera.far;\n  this.ssrMaterial.uniforms['surfDist'].value = this.surfDist;\n  this.ssrMaterial.uniforms['resolution'].value.set(this.width, this.height);\n  this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\n  this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse); // normal material\n\n  this.normalMaterial = new MeshNormalMaterial({\n    morphTargets\n  });\n  this.normalMaterial.blending = NoBlending; // if (this.isSelective) {\n  // metalnessOn material\n\n  this.metalnessOnMaterial = new MeshBasicMaterial({\n    color: 'white'\n  }); // metalnessOff material\n\n  this.metalnessOffMaterial = new MeshBasicMaterial({\n    color: 'black'\n  }); // }\n  // blur material\n\n  this.blurMaterial = new ShaderMaterial({\n    defines: Object.assign({}, SSRBlurShader.defines),\n    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n    vertexShader: SSRBlurShader.vertexShader,\n    fragmentShader: SSRBlurShader.fragmentShader\n  });\n  this.blurMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n  this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height); // blur material 2\n\n  this.blurMaterial2 = new ShaderMaterial({\n    defines: Object.assign({}, SSRBlurShader.defines),\n    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n    vertexShader: SSRBlurShader.vertexShader,\n    fragmentShader: SSRBlurShader.fragmentShader\n  });\n  this.blurMaterial2.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;\n  this.blurMaterial2.uniforms['resolution'].value.set(this.width, this.height); // // blur material 3\n  // this.blurMaterial3 = new ShaderMaterial({\n  //   defines: Object.assign({}, SSRBlurShader.defines),\n  //   uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n  //   vertexShader: SSRBlurShader.vertexShader,\n  //   fragmentShader: SSRBlurShader.fragmentShader\n  // });\n  // this.blurMaterial3.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;\n  // this.blurMaterial3.uniforms['resolution'].value.set(this.width, this.height);\n  // material for rendering the depth\n\n  this.depthRenderMaterial = new ShaderMaterial({\n    defines: Object.assign({}, SSRDepthShader.defines),\n    uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),\n    vertexShader: SSRDepthShader.vertexShader,\n    fragmentShader: SSRDepthShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.depthRenderMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture;\n  this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;\n  this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far; // material for rendering the content of a render target\n\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(CopyShader.uniforms),\n    vertexShader: CopyShader.vertexShader,\n    fragmentShader: CopyShader.fragmentShader,\n    transparent: true,\n    depthTest: false,\n    depthWrite: false,\n    blendSrc: SrcAlphaFactor,\n    blendDst: OneMinusSrcAlphaFactor,\n    blendEquation: AddEquation,\n    blendSrcAlpha: SrcAlphaFactor,\n    blendDstAlpha: OneMinusSrcAlphaFactor,\n    blendEquationAlpha: AddEquation // premultipliedAlpha:true,\n\n  });\n  this.fsQuad = new FullScreenQuad(null);\n  this.originalClearColor = new Color();\n};\n\nSSRPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSRPass,\n  dispose: function () {\n    // dispose render targets\n    this.beautyRenderTarget.dispose();\n    this.prevRenderTarget.dispose();\n    this.normalRenderTarget.dispose(); // if (this.isSelective)\n\n    this.metalnessRenderTarget.dispose();\n    this.ssrRenderTarget.dispose();\n    this.blurRenderTarget.dispose();\n    this.blurRenderTarget2.dispose(); // this.blurRenderTarget3.dispose();\n    // dispose materials\n\n    this.normalMaterial.dispose(); // if (this.isSelective) {\n\n    this.metalnessOnMaterial.dispose();\n    this.metalnessOffMaterial.dispose(); // }\n\n    this.blurMaterial.dispose();\n    this.blurMaterial2.dispose();\n    this.copyMaterial.dispose();\n    this.depthRenderMaterial.dispose(); // dipsose full screen quad\n\n    this.fsQuad.dispose();\n  },\n  render: function (renderer, writeBuffer\n  /*, readBuffer, deltaTime, maskActive */\n  ) {\n    // render beauty and depth\n    if (this.encoding) this.beautyRenderTarget.texture.encoding = this.encoding;\n    renderer.setRenderTarget(this.beautyRenderTarget);\n    renderer.clear();\n\n    if (this.groundReflector) {\n      this.groundReflector.doRender(this.renderer, this.scene, this.camera);\n      this.groundReflector.visible = true;\n    }\n\n    renderer.render(this.scene, this.camera);\n    if (this.groundReflector) this.groundReflector.visible = false; // render normals\n\n    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0); // render metalnesses\n\n    if (this.isSelective) {\n      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);\n    } // render SSR\n\n\n    this.ssrMaterial.uniforms['opacity'].value = this.opacity;\n    this.ssrMaterial.uniforms['maxDistance'].value = this.maxDistance;\n    this.ssrMaterial.uniforms['surfDist'].value = this.surfDist;\n    this.ssrMaterial.uniforms['thickTolerance'].value = this.thickTolerance;\n    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget); // render blur\n\n    if (this.isBlur) {\n      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);\n      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2); // this.renderPass(renderer, this.blurMaterial3, this.blurRenderTarget3);\n    } // output result to screen\n\n\n    switch (this.output) {\n      case SSRPass.OUTPUT.Default:\n        if (this.isBouncing) {\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n          this.copyMaterial.blending = NormalBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n          this.copyMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        } else {\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n          this.copyMaterial.blending = NormalBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        }\n\n        break;\n\n      case SSRPass.OUTPUT.SSR:\n        if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n\n        if (this.isBouncing) {\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n          this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n          this.copyMaterial.blending = NormalBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n        }\n\n        break;\n\n      case SSRPass.OUTPUT.Beauty:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSRPass.OUTPUT.Depth:\n        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSRPass.OUTPUT.Normal:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSRPass.OUTPUT.Metalness:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.metalnessRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      default:\n        console.warn('THREE.SSRPass: Unknown output type.');\n    }\n  },\n  renderPass: function (renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n    // save original state\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget); // setup pass state\n\n    renderer.autoClear = false;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.fsQuad.material = passMaterial;\n    this.fsQuad.render(renderer); // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  renderOverride: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget);\n    renderer.autoClear = false;\n    clearColor = overrideMaterial.clearColor || clearColor;\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.scene.overrideMaterial = overrideMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = null; // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  renderMetalness: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget);\n    renderer.autoClear = false;\n    clearColor = overrideMaterial.clearColor || clearColor;\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.scene.traverseVisible(child => {\n      child._SSRPassMaterialBack = child.material;\n\n      if (this._selects.includes(child)) {\n        child.material = this.metalnessOnMaterial;\n      } else {\n        child.material = this.metalnessOffMaterial;\n      }\n    });\n    renderer.render(this.scene, this.camera);\n    this.scene.traverseVisible(child => {\n      child.material = child._SSRPassMaterialBack;\n    }); // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  setSize: function (width, height) {\n    this.width = width;\n    this.height = height;\n    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);\n    this.ssrMaterial.needsUpdate = true;\n    this.beautyRenderTarget.setSize(width, height);\n    this.prevRenderTarget.setSize(width, height);\n    this.ssrRenderTarget.setSize(width, height);\n    this.normalRenderTarget.setSize(width, height); // if (this.isSelective)\n\n    this.metalnessRenderTarget.setSize(width, height);\n    this.blurRenderTarget.setSize(width, height);\n    this.blurRenderTarget2.setSize(width, height); // this.blurRenderTarget3.setSize(width, height);\n\n    this.ssrMaterial.uniforms['resolution'].value.set(width, height);\n    this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\n    this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\n    this.blurMaterial.uniforms['resolution'].value.set(width, height);\n    this.blurMaterial2.uniforms['resolution'].value.set(width, height);\n  }\n});\nSSRPass.OUTPUT = {\n  Default: 0,\n  SSR: 1,\n  Beauty: 3,\n  Depth: 4,\n  Normal: 5,\n  Metalness: 7\n};\nexport { SSRPass };","map":null,"metadata":{},"sourceType":"module"}