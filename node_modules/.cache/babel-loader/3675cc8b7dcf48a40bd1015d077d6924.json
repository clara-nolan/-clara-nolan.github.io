{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from 'three';\n\nclass OBJExporter {\n  constructor() {\n    _defineProperty(this, \"output\", void 0);\n\n    _defineProperty(this, \"indexVertex\", void 0);\n\n    _defineProperty(this, \"indexVertexUvs\", void 0);\n\n    _defineProperty(this, \"indexNormals\", void 0);\n\n    _defineProperty(this, \"vertex\", void 0);\n\n    _defineProperty(this, \"color\", void 0);\n\n    _defineProperty(this, \"normal\", void 0);\n\n    _defineProperty(this, \"uv\", void 0);\n\n    _defineProperty(this, \"face\", void 0);\n\n    this.output = '';\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n\n  parse(object) {\n    object.traverse(child => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child);\n      }\n\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child);\n      }\n\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child);\n      }\n    });\n    return this.output;\n  }\n\n  parseMesh(mesh) {\n    let nbVertex = 0;\n    let nbNormals = 0;\n    let nbVertexUvs = 0;\n    const geometry = mesh.geometry;\n    const normalMatrixWorld = new Matrix3();\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n    } // shortcuts\n\n\n    const vertices = geometry.getAttribute('position');\n    const normals = geometry.getAttribute('normal');\n    const uvs = geometry.getAttribute('uv');\n    const indices = geometry.getIndex(); // name of the mesh object\n\n    this.output += `o ${mesh.name}\\n`; // name of the mesh material\n\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\\n`;\n    } // vertices\n\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n        this.vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`;\n      }\n    } // uvs\n\n\n    if (uvs !== undefined) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i);\n        this.uv.y = uvs.getY(i); // transform the uv to export format\n\n        this.output += `vt ${this.uv.x} ${this.uv.y}\\n`;\n      }\n    } // normals\n\n\n    if (normals !== undefined) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i);\n        this.normal.y = normals.getY(i);\n        this.normal.z = normals.getZ(i); // transform the normal to world space\n\n        this.normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`;\n      }\n    } // faces\n\n\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}` : '');\n        } // transform the face to export format\n\n\n        this.output += `f ${this.face.join(' ')}\\n`;\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}` : '');\n        } // transform the face to export format\n\n\n        this.output += `f ${this.face.join(' ')}\\n`;\n      }\n    } // update index\n\n\n    this.indexVertex += nbVertex;\n    this.indexVertexUvs += nbVertexUvs;\n    this.indexNormals += nbNormals;\n  }\n\n  parseLine(line) {\n    let nbVertex = 0;\n    const geometry = line.geometry;\n    const type = line.type;\n\n    if (geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n    } // shortcuts\n\n\n    const vertices = geometry.getAttribute('position'); // name of the line object\n\n    this.output += `o ${line.name}\\n`;\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n        this.vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`;\n      }\n    }\n\n    if (type === 'Line') {\n      this.output += 'l ';\n\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `;\n      }\n\n      this.output += '\\n';\n    }\n\n    if (type === 'LineSegments') {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\\n`;\n      }\n    } // update index\n\n\n    this.indexVertex += nbVertex;\n  }\n\n  parsePoints(points) {\n    let nbVertex = 0;\n    const geometry = points.geometry;\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n    }\n\n    const vertices = geometry.getAttribute('position');\n    const colors = geometry.getAttribute('color');\n    this.output += `o ${points.name}\\n`;\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i);\n        this.vertex.applyMatrix4(points.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`;\n\n        if (colors !== undefined && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i);\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`;\n        }\n\n        this.output += '\\n';\n      }\n    }\n\n    this.output += 'p ';\n\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `;\n    }\n\n    this.output += '\\n'; // update index\n\n    this.indexVertex += nbVertex;\n  }\n\n}\n\nexport { OBJExporter };","map":null,"metadata":{},"sourceType":"module"}