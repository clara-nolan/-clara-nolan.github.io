{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\nconst cb = new Vector3(),\n      ab = new Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nclass Vertex {\n  constructor(v, id) {\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"faces\", void 0);\n\n    _defineProperty(this, \"neighbors\", void 0);\n\n    _defineProperty(this, \"collapseCost\", void 0);\n\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n\n    _defineProperty(this, \"minCost\", 0);\n\n    _defineProperty(this, \"totalCost\", 0);\n\n    _defineProperty(this, \"costCount\", 0);\n\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  }\n\n} // we use a triangle class to represent structure of face slightly differently\n\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"c\", void 0);\n\n    _defineProperty(this, \"v1\", void 0);\n\n    _defineProperty(this, \"v2\", void 0);\n\n    _defineProperty(this, \"v3\", void 0);\n\n    _defineProperty(this, \"normal\", new Vector3());\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n\n}\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\n\nclass SimplifyModifier {\n  constructor() {\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      const borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        this.removeVertex(u, vertices);\n        return;\n      }\n\n      let i;\n      const tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\n      // O(n * n) approach. TODO optimize this\n      let least = vertices[0];\n\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n\n    _defineProperty(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (let name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      const vertices = [];\n      const faces = []; // add vertices\n\n      const positionAttribute = geometry.getAttribute('position');\n\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      const geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n\n      let nextVertex;\n      let z = count;\n\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = []; //\n\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      } //\n\n\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n\n    removeFromArray(vertices, v);\n  }\n\n}\n\nexport { SimplifyModifier };","map":null,"metadata":{},"sourceType":"module"}