{"ast":null,"code":"import { Quaternion } from 'three';\n\nconst calculateCameraRotation = (scrollOffset, rotationTrail) => {\n  const initialRotationNode = [...rotationTrail].sort((a, b) => b.offset - a.offset).find(rotationNode => rotationNode.offset <= scrollOffset);\n  const finalRotationNode = rotationTrail[rotationTrail.findIndex(rotationNode => (rotationNode == null ? void 0 : rotationNode.offset) === (initialRotationNode == null ? void 0 : initialRotationNode.offset)) + 1];\n  const calculateScrollOffsetRelativeToCurrentRoatationSlerp = (scrollOffset - initialRotationNode.offset) / ((finalRotationNode == null ? void 0 : finalRotationNode.offset) - (initialRotationNode == null ? void 0 : initialRotationNode.offset)); //interpolate camera rotation between nodes in the rotationTrail array\n\n  const camRotation = new Quaternion().slerpQuaternions(new Quaternion().setFromEuler(initialRotationNode == null ? void 0 : initialRotationNode.rotation), new Quaternion().setFromEuler(finalRotationNode == null ? void 0 : finalRotationNode.rotation), calculateScrollOffsetRelativeToCurrentRoatationSlerp);\n  return camRotation;\n};\n\nexport default calculateCameraRotation;","map":{"version":3,"names":["Quaternion","calculateCameraRotation","scrollOffset","rotationTrail","initialRotationNode","sort","a","b","offset","find","rotationNode","finalRotationNode","findIndex","calculateScrollOffsetRelativeToCurrentRoatationSlerp","camRotation","slerpQuaternions","setFromEuler","rotation"],"sources":["C:/Users/clara/Documents/personalSite/clara-nolan.github.io/src/utils/calcualteCameraRotation.js"],"sourcesContent":["import { Quaternion } from 'three';\r\n\r\nconst calculateCameraRotation = (scrollOffset, rotationTrail) => {\r\n  const initialRotationNode = [...rotationTrail]\r\n    .sort((a, b) => b.offset - a.offset)\r\n    .find((rotationNode) => rotationNode.offset <= scrollOffset);\r\n\r\n  const finalRotationNode =\r\n    rotationTrail[\r\n      rotationTrail.findIndex(\r\n        (rotationNode) => rotationNode?.offset === initialRotationNode?.offset\r\n      ) + 1\r\n    ];\r\n\r\n  const calculateScrollOffsetRelativeToCurrentRoatationSlerp =\r\n    (scrollOffset - initialRotationNode.offset) /\r\n    (finalRotationNode?.offset - initialRotationNode?.offset);\r\n\r\n  //interpolate camera rotation between nodes in the rotationTrail array\r\n  const camRotation = new Quaternion().slerpQuaternions(\r\n    new Quaternion().setFromEuler(initialRotationNode?.rotation),\r\n    new Quaternion().setFromEuler(finalRotationNode?.rotation),\r\n    calculateScrollOffsetRelativeToCurrentRoatationSlerp\r\n  );\r\n\r\n  return camRotation;\r\n};\r\n\r\nexport default calculateCameraRotation;\r\n"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;;AAEA,MAAMC,uBAAuB,GAAG,CAACC,YAAD,EAAeC,aAAf,KAAiC;EAC/D,MAAMC,mBAAmB,GAAG,CAAC,GAAGD,aAAJ,EACzBE,IADyB,CACpB,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAC,CAACC,MAAF,GAAWF,CAAC,CAACE,MADH,EAEzBC,IAFyB,CAEnBC,YAAD,IAAkBA,YAAY,CAACF,MAAb,IAAuBN,YAFrB,CAA5B;EAIA,MAAMS,iBAAiB,GACrBR,aAAa,CACXA,aAAa,CAACS,SAAd,CACGF,YAAD,IAAkB,CAAAA,YAAY,QAAZ,YAAAA,YAAY,CAAEF,MAAd,OAAyBJ,mBAAzB,oBAAyBA,mBAAmB,CAAEI,MAA9C,CADpB,IAEI,CAHO,CADf;EAOA,MAAMK,oDAAoD,GACxD,CAACX,YAAY,GAAGE,mBAAmB,CAACI,MAApC,KACC,CAAAG,iBAAiB,QAAjB,YAAAA,iBAAiB,CAAEH,MAAnB,KAA4BJ,mBAA5B,oBAA4BA,mBAAmB,CAAEI,MAAjD,CADD,CADF,CAZ+D,CAgB/D;;EACA,MAAMM,WAAW,GAAG,IAAId,UAAJ,GAAiBe,gBAAjB,CAClB,IAAIf,UAAJ,GAAiBgB,YAAjB,CAA8BZ,mBAA9B,oBAA8BA,mBAAmB,CAAEa,QAAnD,CADkB,EAElB,IAAIjB,UAAJ,GAAiBgB,YAAjB,CAA8BL,iBAA9B,oBAA8BA,iBAAiB,CAAEM,QAAjD,CAFkB,EAGlBJ,oDAHkB,CAApB;EAMA,OAAOC,WAAP;AACD,CAxBD;;AA0BA,eAAeb,uBAAf"},"metadata":{},"sourceType":"module"}