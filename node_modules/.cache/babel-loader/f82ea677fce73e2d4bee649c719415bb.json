{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from 'three';\n\nclass ColladaExporter {\n  constructor() {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"geometryInfo\", void 0);\n\n    _defineProperty(this, \"materialMap\", void 0);\n\n    _defineProperty(this, \"imageMap\", void 0);\n\n    _defineProperty(this, \"textures\", void 0);\n\n    _defineProperty(this, \"libraryImages\", void 0);\n\n    _defineProperty(this, \"libraryGeometries\", void 0);\n\n    _defineProperty(this, \"libraryEffects\", void 0);\n\n    _defineProperty(this, \"libraryMaterials\", void 0);\n\n    _defineProperty(this, \"canvas\", void 0);\n\n    _defineProperty(this, \"ctx\", void 0);\n\n    _defineProperty(this, \"transMat\", void 0);\n\n    _defineProperty(this, \"getFuncs\", ['getX', 'getY', 'getZ', 'getW']);\n\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = new WeakMap();\n    this.materialMap = new WeakMap();\n    this.imageMap = new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n\n  parse(object, onDone) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.options = { ...this.options,\n      ...options\n    };\n\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.');\n      return null;\n    }\n\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.');\n      return null;\n    }\n\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.');\n      return null;\n    }\n\n    if (this.options.textureDirectory !== '') {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n    }\n\n    if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    }\n\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : ''}</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${this.libraryImages.join('')}</library_images>`;\n    dae += `<library_effects>${this.libraryEffects.join('')}</library_effects>`;\n    dae += `<library_materials>${this.libraryMaterials.join('')}</library_materials>`;\n    dae += `<library_geometries>${this.libraryGeometries.join('')}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += '</COLLADA>';\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res));\n    }\n\n    return res;\n  } // Convert the urdf xml into a well-formatted, indented format\n\n\n  format(urdf) {\n    var _urdf$match$map$join, _urdf$match;\n\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : '';\n\n    let tagnum = 0;\n    return (_urdf$match$map$join = (_urdf$match = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) === null || _urdf$match === void 0 ? void 0 : _urdf$match.map(tag => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n\n      const res = `${pad('  ', tagnum)}${tag}`;\n\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n\n      return res;\n    }).join('\\n')) != null ? _urdf$match$map$join : '';\n  } // Convert an image into a png format for saving\n\n\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n\n    return buf;\n  }\n\n  imageToData(image, ext) {\n    var _this$ctx;\n\n    this.canvas = this.canvas || document.createElement('canvas');\n    this.ctx = this.ctx || this.canvas.getContext('2d');\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_this$ctx = this.ctx) === null || _this$ctx === void 0 ? void 0 : _this$ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n    return this.base64ToBuffer(base64data);\n  } // gets the attribute array. Generate a new array if the attribute is interleaved\n\n\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      // use the typed array constructor to save on memory\n      const TypedArrayConstructor = attr.array.constructor; // @ts-expect-error\n\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n\n      return arr;\n    } else {\n      return attr.array;\n    }\n  } // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n\n\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor; // @ts-expect-error\n\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  } // Returns the string for a geometry's attribute\n\n\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? `${`<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join('')}</accessor></technique_common></source>` : '';\n    return res;\n  } // Returns the string for a node's transform information\n\n\n  getTransform(o) {\n    // ensure the object's matrix is up to date\n    // before saving the transform\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return `<matrix>${this.transMat.toArray().join(' ')}</matrix>`;\n  } // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n\n\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n\n    if (!info) {\n      // convert the geometry to bufferGeometry if it isn't already\n      const bufferGeometry = g;\n\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`;\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n        start: 0,\n        count: indexCount,\n        materialIndex: 0\n      }];\n      const gname = g.name ? ` name=\"${g.name}\"` : '';\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`; // define the geometry node and the vertices for the geometry\n\n      const posName = `${meshid}-position`;\n      const vertName = `${meshid}-vertices`;\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`; // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n      // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n      // models with attributes that share an offset.\n      // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n      // serialize normals\n\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n\n      if ('normal' in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`;\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n      } // serialize uvs\n\n\n      if ('uv' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n      } // serialize lightmap uvs\n\n\n      if ('uv2' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float');\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n      } // serialize colors\n\n\n      if ('color' in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`;\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n      }\n\n      let indexArray = null;\n\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i;\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n        gnode += triangleInputs;\n        gnode += `<p>${subarr.join(' ')}</p>`;\n        gnode += '</triangles>';\n      }\n\n      gnode += '</mesh></geometry>';\n      this.libraryGeometries.push(gnode);\n      info = {\n        meshid,\n        bufferGeometry\n      };\n      this.geometryInfo.set(g, info);\n    }\n\n    return info;\n  } // Process the given texture into the image library\n  // Returns the image library\n\n\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`;\n      const ext = 'png';\n      const name = tex.name || texid;\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n\n      if (this.options.version === '1.5.0') {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;\n      } else {\n        // version image node 1.4.1\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;\n      }\n\n      imageNode += '</image>';\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n\n    return texid;\n  } // Process the given material into the material and effect libraries\n  // Returns the material id\n\n\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`;\n      let type = 'phong';\n\n      if (m instanceof MeshLambertMaterial) {\n        type = 'lambert';\n      } else if (m instanceof MeshBasicMaterial) {\n        type = 'constant';\n\n        if (m.map !== null) {\n          // The Collada spec does not support diffuse texture maps with the\n          // constant shader type.\n          // mrdoob/three.js#15469\n          console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n        }\n      }\n\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n\n        let transparencyNode = '';\n\n        if (m.transparent) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'}</transparent>`;\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== 'constant' ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ''}${type !== 'constant' ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>` : ''}${type === 'phong' ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : ''}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ''}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ''}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ''}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ''}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : ''}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : '';\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n\n    return matid;\n  } // Recursively process the object into a scene\n\n\n  processObject(o) {\n    let node = `<node name=\"${o.name}\">`;\n    node += this.getTransform(o);\n    new Mesh();\n\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      // function returns the id associated with the mesh and a \"BufferGeometry\" version\n      // of the geometry in case it's not a geometry.\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n      let matids = null;\n      let matidsArray; // get a list of materials to bind to the sub groups of the geometry.\n      // If the amount of subgroups is greater than the materials, than reuse\n      // the materials.\n\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join('')}</technique_common></bind_material>` : '')}</instance_geometry>`;\n    }\n\n    o.children.forEach(c => node += this.processObject(c));\n    node += '</node>';\n    return node;\n  }\n\n}\n\nexport { ColladaExporter };","map":null,"metadata":{},"sourceType":"module"}