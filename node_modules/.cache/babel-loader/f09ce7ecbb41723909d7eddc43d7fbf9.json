{"ast":null,"code":";\n\n(function (root, factory) {\n  // istanbul ignore next\n  if (typeof define === \"function\" && define.amd) {\n    // istanbul ignore next\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    // istanbul ignore next\n    root.regexpToAst = factory();\n  }\n})(typeof self !== \"undefined\" ? // istanbul ignore next\nself : this, function () {\n  // references\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  function RegExpParser() {}\n\n  RegExpParser.prototype.saveState = function () {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  };\n\n  RegExpParser.prototype.restoreState = function (newState) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  };\n\n  RegExpParser.prototype.pattern = function (input) {\n    // parser state\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    var value = this.disjunction();\n    this.consumeChar(\"/\");\n    var flags = {\n      type: \"Flags\",\n      loc: {\n        begin: this.idx,\n        end: input.length\n      },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n\n    return {\n      type: \"Pattern\",\n      flags: flags,\n      value: value,\n      loc: this.loc(0)\n    };\n  };\n\n  RegExpParser.prototype.disjunction = function () {\n    var alts = [];\n    var begin = this.idx;\n    alts.push(this.alternative());\n\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n\n    return {\n      type: \"Disjunction\",\n      value: alts,\n      loc: this.loc(begin)\n    };\n  };\n\n  RegExpParser.prototype.alternative = function () {\n    var terms = [];\n    var begin = this.idx;\n\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n\n    return {\n      type: \"Alternative\",\n      value: terms,\n      loc: this.loc(begin)\n    };\n  };\n\n  RegExpParser.prototype.term = function () {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  };\n\n  RegExpParser.prototype.assertion = function () {\n    var begin = this.idx;\n\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin)\n        };\n\n      case \"$\":\n        return {\n          type: \"EndAnchor\",\n          loc: this.loc(begin)\n        };\n      // '\\b' or '\\B'\n\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin)\n            };\n\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin)\n            };\n        } // istanbul ignore next\n\n\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n\n      case \"(\":\n        this.consumeChar(\"?\");\n        var type;\n\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n\n        ASSERT_EXISTS(type);\n        var disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type: type,\n          value: disjunction,\n          loc: this.loc(begin)\n        };\n    } // istanbul ignore next\n\n\n    ASSERT_NEVER_REACH_HERE();\n  };\n\n  RegExpParser.prototype.quantifier = function (isBacktracking) {\n    var range;\n    var begin = this.idx;\n\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n\n      case \"{\":\n        var atLeast = this.integerIncludingZero();\n\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast: atLeast,\n              atMost: atLeast\n            };\n            break;\n\n          case \",\":\n            var atMost;\n\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast: atLeast,\n                atMost: atMost\n              };\n            } else {\n              range = {\n                atLeast: atLeast,\n                atMost: Infinity\n              };\n            }\n\n            this.consumeChar(\"}\");\n            break;\n        } // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n\n\n        if (isBacktracking === true && range === undefined) {\n          return undefined;\n        }\n\n        ASSERT_EXISTS(range);\n        break;\n    } // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n    // causes severe performance degradations\n\n\n    if (isBacktracking === true && range === undefined) {\n      return undefined;\n    }\n\n    ASSERT_EXISTS(range);\n\n    if (this.peekChar(0) === \"?\") {\n      this.consumeChar(\"?\");\n      range.greedy = false;\n    } else {\n      range.greedy = true;\n    }\n\n    range.type = \"Quantifier\";\n    range.loc = this.loc(begin);\n    return range;\n  };\n\n  RegExpParser.prototype.atom = function () {\n    var atom;\n    var begin = this.idx;\n\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n\n      case \"[\":\n        atom = this.characterClass();\n        break;\n\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n\n    if (atom === undefined && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n\n    ASSERT_EXISTS(atom);\n    atom.loc = this.loc(begin);\n\n    if (this.isQuantifier()) {\n      atom.quantifier = this.quantifier();\n    }\n\n    return atom;\n  };\n\n  RegExpParser.prototype.dotAll = function () {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  };\n\n  RegExpParser.prototype.atomEscape = function () {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n\n      case \"0\":\n        return this.nulCharacterAtom();\n\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n\n  RegExpParser.prototype.decimalEscapeAtom = function () {\n    var value = this.positiveInteger();\n    return {\n      type: \"GroupBackReference\",\n      value: value\n    };\n  };\n\n  RegExpParser.prototype.characterClassEscape = function () {\n    var set;\n    var complement = false;\n\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n\n      case \"w\":\n        set = wordCharCodes;\n        break;\n\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n\n    ASSERT_EXISTS(set);\n    return {\n      type: \"Set\",\n      value: set,\n      complement: complement\n    };\n  };\n\n  RegExpParser.prototype.controlEscapeAtom = function () {\n    var escapeCode;\n\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n\n      case \"t\":\n        escapeCode = cc(\"\\t\");\n        break;\n\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n\n    ASSERT_EXISTS(escapeCode);\n    return {\n      type: \"Character\",\n      value: escapeCode\n    };\n  };\n\n  RegExpParser.prototype.controlLetterEscapeAtom = function () {\n    this.consumeChar(\"c\");\n    var letter = this.popChar();\n\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n\n    var letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return {\n      type: \"Character\",\n      value: letterCode\n    };\n  };\n\n  RegExpParser.prototype.nulCharacterAtom = function () {\n    // TODO implement '[lookahead âˆ‰ DecimalDigit]'\n    // TODO: for the deprecated octal escape sequence\n    this.consumeChar(\"0\");\n    return {\n      type: \"Character\",\n      value: cc(\"\\0\")\n    };\n  };\n\n  RegExpParser.prototype.hexEscapeSequenceAtom = function () {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  };\n\n  RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function () {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  };\n\n  RegExpParser.prototype.identityEscapeAtom = function () {\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n    var escapedChar = this.popChar();\n    return {\n      type: \"Character\",\n      value: cc(escapedChar)\n    };\n  };\n\n  RegExpParser.prototype.classPatternCharacterAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\": // istanbul ignore next\n\n      case \"\\\\\": // istanbul ignore next\n\n      case \"]\":\n        throw Error(\"TBD\");\n\n      default:\n        var nextChar = this.popChar();\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n\n  RegExpParser.prototype.characterClass = function () {\n    var set = [];\n    var complement = false;\n    this.consumeChar(\"[\");\n\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n\n    while (this.isClassAtom()) {\n      var from = this.classAtom();\n      var isFromSingleChar = from.type === \"Character\";\n\n      if (isFromSingleChar && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        var to = this.classAtom();\n        var isToSingleChar = to.type === \"Character\"; // a range can only be used when both sides are single characters\n\n        if (isToSingleChar) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n\n          set.push({\n            from: from.value,\n            to: to.value\n          });\n        } else {\n          // literal dash\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n\n    this.consumeChar(\"]\");\n    return {\n      type: \"Set\",\n      complement: complement,\n      value: set\n    };\n  };\n\n  RegExpParser.prototype.classAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\": // istanbul ignore next\n\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n\n      case \"\\\\\":\n        return this.classEscape();\n\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  };\n\n  RegExpParser.prototype.classEscape = function () {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return {\n          type: \"Character\",\n          value: cc(\"\\u0008\")\n        };\n\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n\n      case \"0\":\n        return this.nulCharacterAtom();\n\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n\n  RegExpParser.prototype.group = function () {\n    var capturing = true;\n    this.consumeChar(\"(\");\n\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n\n      default:\n        this.groupIdx++;\n        break;\n    }\n\n    var value = this.disjunction();\n    this.consumeChar(\")\");\n    var groupAst = {\n      type: \"Group\",\n      capturing: capturing,\n      value: value\n    };\n\n    if (capturing) {\n      groupAst.idx = this.groupIdx;\n    }\n\n    return groupAst;\n  };\n\n  RegExpParser.prototype.positiveInteger = function () {\n    var number = this.popChar(); // istanbul ignore next - can't ever get here due to previous lookahead checks\n    // still implementing this error checking in case this ever changes.\n\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  };\n\n  RegExpParser.prototype.integerIncludingZero = function () {\n    var number = this.popChar();\n\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  };\n\n  RegExpParser.prototype.patternCharacter = function () {\n    var nextChar = this.popChar();\n\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\": // istanbul ignore next\n\n      case \"^\": // istanbul ignore next\n\n      case \"$\": // istanbul ignore next\n\n      case \"\\\\\": // istanbul ignore next\n\n      case \".\": // istanbul ignore next\n\n      case \"*\": // istanbul ignore next\n\n      case \"+\": // istanbul ignore next\n\n      case \"?\": // istanbul ignore next\n\n      case \"(\": // istanbul ignore next\n\n      case \")\": // istanbul ignore next\n\n      case \"[\": // istanbul ignore next\n\n      case \"|\":\n        // istanbul ignore next\n        throw Error(\"TBD\");\n\n      default:\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n\n  RegExpParser.prototype.isRegExpFlag = function () {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isRangeDash = function () {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  };\n\n  RegExpParser.prototype.isDigit = function () {\n    return decimalPattern.test(this.peekChar(0));\n  };\n\n  RegExpParser.prototype.isClassAtom = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n\n      default:\n        return true;\n    }\n  };\n\n  RegExpParser.prototype.isTerm = function () {\n    return this.isAtom() || this.isAssertion();\n  };\n\n  RegExpParser.prototype.isAtom = function () {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\": // atomEscape\n\n      case \"[\": // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n\n      case \"(\":\n        // group\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isAssertion = function () {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n\n          default:\n            return false;\n        }\n\n      // '(?=' or '(?!'\n\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isQuantifier = function () {\n    var prevState = this.saveState();\n\n    try {\n      return this.quantifier(true) !== undefined;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  };\n\n  RegExpParser.prototype.isPatternCharacter = function () {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n\n      default:\n        return true;\n    }\n  };\n\n  RegExpParser.prototype.parseHexDigits = function (howMany) {\n    var hexString = \"\";\n\n    for (var i = 0; i < howMany; i++) {\n      var hexChar = this.popChar();\n\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n\n      hexString += hexChar;\n    }\n\n    var charCode = parseInt(hexString, 16);\n    return {\n      type: \"Character\",\n      value: charCode\n    };\n  };\n\n  RegExpParser.prototype.peekChar = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n\n    return this.input[this.idx + howMuch];\n  };\n\n  RegExpParser.prototype.popChar = function () {\n    var nextChar = this.peekChar(0);\n    this.consumeChar();\n    return nextChar;\n  };\n\n  RegExpParser.prototype.consumeChar = function (char) {\n    if (char !== undefined && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n\n    this.idx++;\n  };\n\n  RegExpParser.prototype.loc = function (begin) {\n    return {\n      begin: begin,\n      end: this.idx\n    };\n  }; // consts and utilities\n\n\n  var hexDigitPattern = /[0-9a-fA-F]/;\n  var decimalPattern = /[0-9]/;\n  var decimalPatternNoZero = /[1-9]/;\n\n  function cc(char) {\n    return char.charCodeAt(0);\n  }\n\n  function insertToSet(item, set) {\n    if (item.length !== undefined) {\n      item.forEach(function (subItem) {\n        set.push(subItem);\n      });\n    } else {\n      set.push(item);\n    }\n  }\n\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw \"duplicate flag \" + flagKey;\n    }\n\n    flagObj[flagKey] = true;\n  }\n\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error(\"Internal Error - Should never get here!\");\n    }\n  } // istanbul ignore next\n\n\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n\n  var i;\n  var digitsCharCodes = [];\n\n  for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n  }\n\n  var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\n\n  for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n  }\n\n  for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n\n\n  var whitespaceCodes = [cc(\" \"), cc(\"\\f\"), cc(\"\\n\"), cc(\"\\r\"), cc(\"\\t\"), cc(\"\\v\"), cc(\"\\t\"), cc(\"\\u00a0\"), cc(\"\\u1680\"), cc(\"\\u2000\"), cc(\"\\u2001\"), cc(\"\\u2002\"), cc(\"\\u2003\"), cc(\"\\u2004\"), cc(\"\\u2005\"), cc(\"\\u2006\"), cc(\"\\u2007\"), cc(\"\\u2008\"), cc(\"\\u2009\"), cc(\"\\u200a\"), cc(\"\\u2028\"), cc(\"\\u2029\"), cc(\"\\u202f\"), cc(\"\\u205f\"), cc(\"\\u3000\"), cc(\"\\ufeff\")];\n\n  function BaseRegExpVisitor() {}\n\n  BaseRegExpVisitor.prototype.visitChildren = function (node) {\n    for (var key in node) {\n      var child = node[key];\n      /* istanbul ignore else */\n\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== undefined) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach(function (subChild) {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  };\n\n  BaseRegExpVisitor.prototype.visit = function (node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n\n      case \"Set\":\n        this.visitSet(node);\n        break;\n\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n\n    this.visitChildren(node);\n  };\n\n  BaseRegExpVisitor.prototype.visitPattern = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitFlags = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitDisjunction = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitAlternative = function (node) {}; // Assertion\n\n\n  BaseRegExpVisitor.prototype.visitStartAnchor = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitEndAnchor = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitWordBoundary = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitNonWordBoundary = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitLookahead = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitNegativeLookahead = function (node) {}; // atoms\n\n\n  BaseRegExpVisitor.prototype.visitCharacter = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitSet = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitGroup = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitGroupBackReference = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitQuantifier = function (node) {};\n\n  return {\n    RegExpParser: RegExpParser,\n    BaseRegExpVisitor: BaseRegExpVisitor,\n    VERSION: \"0.5.0\"\n  };\n});","map":null,"metadata":{},"sourceType":"script"}