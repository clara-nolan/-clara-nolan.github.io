{"ast":null,"code":"import * as t from \"three\";\n\nfunction e(e, i) {\n  const s = new t.Matrix4(),\n        r = new t.Ray(),\n        a = new t.Sphere(),\n        o = new t.Vector3(),\n        n = this.geometry;\n  if (a.copy(n.boundingSphere), a.applyMatrix4(this.matrixWorld), !1 === e.ray.intersectSphere(a, o)) return;\n  s.copy(this.matrixWorld).invert(), r.copy(e.ray).applyMatrix4(s);\n  const u = new t.Vector3(),\n        h = new t.Vector3(),\n        l = new t.Vector3(),\n        p = this instanceof t.LineSegments ? 2 : 1,\n        c = n.index,\n        f = n.attributes;\n\n  if (null !== c) {\n    const t = c.array,\n          s = f.position.array,\n          a = f.width.array;\n\n    for (let n = 0, c = t.length - 1; n < c; n += p) {\n      const p = t[n],\n            f = t[n + 1];\n      u.fromArray(s, 3 * p), h.fromArray(s, 3 * f);\n      const d = null != a[Math.floor(n / 3)] ? a[Math.floor(n / 3)] : 1,\n            v = e.params.Line.threshold + this.material.lineWidth * d / 2,\n            m = v * v;\n      if (r.distanceSqToSegment(u, h, o, l) > m) continue;\n      o.applyMatrix4(this.matrixWorld);\n      const y = e.ray.origin.distanceTo(o);\n      y < e.near || y > e.far || (i.push({\n        distance: y,\n        point: l.clone().applyMatrix4(this.matrixWorld),\n        index: n,\n        face: null,\n        faceIndex: null,\n        object: this\n      }), n = c);\n    }\n  }\n}\n\nfunction i(t, e, i, s, r) {\n  let a;\n  if (t = t.subarray || t.slice ? t : t.buffer, i = i.subarray || i.slice ? i : i.buffer, t = e ? t.subarray ? t.subarray(e, r && e + r) : t.slice(e, r && e + r) : t, i.set) i.set(t, s);else for (a = 0; a < t.length; a++) i[a + s] = t[a];\n  return i;\n}\n\nclass s extends t.BufferGeometry {\n  constructor() {\n    super(), this.type = \"MeshLine\", this.isMeshLine = !0, this.positions = [], this.raycast = e, this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this._points = [], this._geom = null, this.widthCallback = null, this.matrixWorld = new t.Matrix4(), Object.defineProperties(this, {\n      geometry: {\n        enumerable: !0,\n\n        get() {\n          return this;\n        }\n\n      },\n      geom: {\n        enumerable: !0,\n\n        get() {\n          return this._geom;\n        },\n\n        set(t) {\n          this.setGeometry(t, this.widthCallback);\n        }\n\n      },\n      points: {\n        enumerable: !0,\n\n        get() {\n          return this._points;\n        },\n\n        set(t) {\n          this.setPoints(t, this.widthCallback);\n        }\n\n      }\n    });\n  }\n\n  setMatrixWorld(t) {\n    this.matrixWorld = t;\n  }\n\n  setGeometry(e, i) {\n    this._geometry = e, e instanceof t.BufferGeometry ? this.setPoints(e.getAttribute(\"position\").array, i) : this.setPoints(e, i);\n  }\n\n  setPoints(e, i) {\n    if (e instanceof Float32Array || e instanceof Array) {\n      if (this._points = e, this.widthCallback = i, this.positions = [], this.counters = [], e.length && e[0] instanceof t.Vector3) for (var s = 0; s < e.length; s++) {\n        const t = e[s];\n        var r = s / e.length;\n        this.positions.push(t.x, t.y, t.z), this.positions.push(t.x, t.y, t.z), this.counters.push(r), this.counters.push(r);\n      } else for (s = 0; s < e.length; s += 3) {\n        r = s / e.length;\n        this.positions.push(e[s], e[s + 1], e[s + 2]), this.positions.push(e[s], e[s + 1], e[s + 2]), this.counters.push(r), this.counters.push(r);\n      }\n      this.process();\n    } else console.error(\"ERROR: The BufferArray of points is not instancied correctly.\");\n  }\n\n  compareV3(t, e) {\n    const i = 6 * t,\n          s = 6 * e;\n    return this.positions[i] === this.positions[s] && this.positions[i + 1] === this.positions[s + 1] && this.positions[i + 2] === this.positions[s + 2];\n  }\n\n  copyV3(t) {\n    const e = 6 * t;\n    return [this.positions[e], this.positions[e + 1], this.positions[e + 2]];\n  }\n\n  process() {\n    const e = this.positions.length / 6;\n    let i, s;\n    this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], s = this.compareV3(0, e - 1) ? this.copyV3(e - 2) : this.copyV3(0), this.previous.push(s[0], s[1], s[2]), this.previous.push(s[0], s[1], s[2]);\n\n    for (let t = 0; t < e; t++) {\n      if (this.side.push(1), this.side.push(-1), i = this.widthCallback ? this.widthCallback(t / (e - 1)) : 1, this.width.push(i), this.width.push(i), this.uvs.push(t / (e - 1), 0), this.uvs.push(t / (e - 1), 1), t < e - 1) {\n        s = this.copyV3(t), this.previous.push(s[0], s[1], s[2]), this.previous.push(s[0], s[1], s[2]);\n        const e = 2 * t;\n        this.indices_array.push(e, e + 1, e + 2), this.indices_array.push(e + 2, e + 1, e + 3);\n      }\n\n      t > 0 && (s = this.copyV3(t), this.next.push(s[0], s[1], s[2]), this.next.push(s[0], s[1], s[2]));\n    }\n\n    s = this.compareV3(e - 1, 0) ? this.copyV3(1) : this.copyV3(e - 1), this.next.push(s[0], s[1], s[2]), this.next.push(s[0], s[1], s[2]), this._attributes && this._attributes.position.count === this.positions.length ? (this._attributes.position.copyArray(new Float32Array(this.positions)), this._attributes.position.needsUpdate = !0, this._attributes.previous.copyArray(new Float32Array(this.previous)), this._attributes.previous.needsUpdate = !0, this._attributes.next.copyArray(new Float32Array(this.next)), this._attributes.next.needsUpdate = !0, this._attributes.side.copyArray(new Float32Array(this.side)), this._attributes.side.needsUpdate = !0, this._attributes.width.copyArray(new Float32Array(this.width)), this._attributes.width.needsUpdate = !0, this._attributes.uv.copyArray(new Float32Array(this.uvs)), this._attributes.uv.needsUpdate = !0, this._attributes.index.copyArray(new Uint16Array(this.indices_array)), this._attributes.index.needsUpdate = !0) : this._attributes = {\n      position: new t.BufferAttribute(new Float32Array(this.positions), 3),\n      previous: new t.BufferAttribute(new Float32Array(this.previous), 3),\n      next: new t.BufferAttribute(new Float32Array(this.next), 3),\n      side: new t.BufferAttribute(new Float32Array(this.side), 1),\n      width: new t.BufferAttribute(new Float32Array(this.width), 1),\n      uv: new t.BufferAttribute(new Float32Array(this.uvs), 2),\n      index: new t.BufferAttribute(new Uint16Array(this.indices_array), 1),\n      counters: new t.BufferAttribute(new Float32Array(this.counters), 1)\n    }, this.setAttribute(\"position\", this._attributes.position), this.setAttribute(\"previous\", this._attributes.previous), this.setAttribute(\"next\", this._attributes.next), this.setAttribute(\"side\", this._attributes.side), this.setAttribute(\"width\", this._attributes.width), this.setAttribute(\"uv\", this._attributes.uv), this.setAttribute(\"counters\", this._attributes.counters), this.setIndex(this._attributes.index), this.computeBoundingSphere(), this.computeBoundingBox();\n  }\n\n  advance(_ref) {\n    let {\n      x: t,\n      y: e,\n      z: s\n    } = _ref;\n    const r = this._attributes.position.array,\n          a = this._attributes.previous.array,\n          o = this._attributes.next.array,\n          n = r.length;\n    i(r, 0, a, 0, n), i(r, 6, r, 0, n - 6), r[n - 6] = t, r[n - 5] = e, r[n - 4] = s, r[n - 3] = t, r[n - 2] = e, r[n - 1] = s, i(r, 6, o, 0, n - 6), o[n - 6] = t, o[n - 5] = e, o[n - 4] = s, o[n - 3] = t, o[n - 2] = e, o[n - 1] = s, this._attributes.position.needsUpdate = !0, this._attributes.previous.needsUpdate = !0, this._attributes.next.needsUpdate = !0;\n  }\n\n}\n\nt.ShaderChunk.meshline_vert = [\"\", \"#include <common>\", \"\", t.ShaderChunk.logdepthbuf_pars_vertex, t.ShaderChunk.fog_pars_vertex, \"\", \"attribute vec3 previous;\", \"attribute vec3 next;\", \"attribute float side;\", \"attribute float width;\", \"attribute float counters;\", \"\", \"uniform vec2 resolution;\", \"uniform float lineWidth;\", \"uniform vec3 color;\", \"uniform float opacity;\", \"uniform float sizeAttenuation;\", \"\", \"varying vec2 vUV;\", \"varying vec4 vColor;\", \"varying float vCounters;\", \"\", \"vec2 fix( vec4 i, float aspect ) {\", \"\", \"    vec2 res = i.xy / i.w;\", \"    res.x *= aspect;\", \"\\t vCounters = counters;\", \"    return res;\", \"\", \"}\", \"\", \"void main() {\", \"\", \"    float aspect = resolution.x / resolution.y;\", \"\", \"    vColor = vec4( color, opacity );\", \"    vUV = uv;\", \"\", \"    mat4 m = projectionMatrix * modelViewMatrix;\", \"    vec4 finalPosition = m * vec4( position, 1.0 );\", \"    vec4 prevPos = m * vec4( previous, 1.0 );\", \"    vec4 nextPos = m * vec4( next, 1.0 );\", \"\", \"    vec2 currentP = fix( finalPosition, aspect );\", \"    vec2 prevP = fix( prevPos, aspect );\", \"    vec2 nextP = fix( nextPos, aspect );\", \"\", \"    float w = lineWidth * width;\", \"\", \"    vec2 dir;\", \"    if( nextP == currentP ) dir = normalize( currentP - prevP );\", \"    else if( prevP == currentP ) dir = normalize( nextP - currentP );\", \"    else {\", \"        vec2 dir1 = normalize( currentP - prevP );\", \"        vec2 dir2 = normalize( nextP - currentP );\", \"        dir = normalize( dir1 + dir2 );\", \"\", \"        vec2 perp = vec2( -dir1.y, dir1.x );\", \"        vec2 miter = vec2( -dir.y, dir.x );\", \"        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );\", \"\", \"    }\", \"\", \"    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;\", \"    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\", \"    normal.xy *= .5 * w;\", \"    normal *= projectionMatrix;\", \"    if( sizeAttenuation == 0. ) {\", \"        normal.xy *= finalPosition.w;\", \"        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\", \"    }\", \"\", \"    finalPosition.xy += normal.xy * side;\", \"\", \"    gl_Position = finalPosition;\", \"\", t.ShaderChunk.logdepthbuf_vertex, t.ShaderChunk.fog_vertex && \"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", t.ShaderChunk.fog_vertex, \"}\"].join(\"\\n\"), t.ShaderChunk.meshline_frag = [\"\", t.ShaderChunk.fog_pars_fragment, t.ShaderChunk.logdepthbuf_pars_fragment, \"\", \"uniform sampler2D map;\", \"uniform sampler2D alphaMap;\", \"uniform float useMap;\", \"uniform float useAlphaMap;\", \"uniform float useDash;\", \"uniform float dashArray;\", \"uniform float dashOffset;\", \"uniform float dashRatio;\", \"uniform float visibility;\", \"uniform float alphaTest;\", \"uniform vec2 repeat;\", \"\", \"varying vec2 vUV;\", \"varying vec4 vColor;\", \"varying float vCounters;\", \"\", \"void main() {\", \"\", t.ShaderChunk.logdepthbuf_fragment, \"\", \"    vec4 c = vColor;\", \"    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );\", \"    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;\", \"    if( c.a < alphaTest ) discard;\", \"    if( useDash == 1. ){\", \"        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\", \"    }\", \"    gl_FragColor = c;\", \"    gl_FragColor.a *= step(vCounters, visibility);\", \"\", t.ShaderChunk.fog_fragment, \"}\"].join(\"\\n\");\n\nclass r extends t.ShaderMaterial {\n  constructor(e) {\n    super({\n      uniforms: Object.assign({}, t.UniformsLib.fog, {\n        lineWidth: {\n          value: 1\n        },\n        map: {\n          value: null\n        },\n        useMap: {\n          value: 0\n        },\n        alphaMap: {\n          value: null\n        },\n        useAlphaMap: {\n          value: 0\n        },\n        color: {\n          value: new t.Color(16777215)\n        },\n        opacity: {\n          value: 1\n        },\n        resolution: {\n          value: new t.Vector2(1, 1)\n        },\n        sizeAttenuation: {\n          value: 1\n        },\n        dashArray: {\n          value: 0\n        },\n        dashOffset: {\n          value: 0\n        },\n        dashRatio: {\n          value: .5\n        },\n        useDash: {\n          value: 0\n        },\n        visibility: {\n          value: 1\n        },\n        alphaTest: {\n          value: 0\n        },\n        repeat: {\n          value: new t.Vector2(1, 1)\n        }\n      }),\n      vertexShader: t.ShaderChunk.meshline_vert,\n      fragmentShader: t.ShaderChunk.meshline_frag\n    }), this.type = \"MeshLineMaterial\", Object.defineProperties(this, {\n      lineWidth: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.lineWidth.value;\n        },\n\n        set(t) {\n          this.uniforms.lineWidth.value = t;\n        }\n\n      },\n      map: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.map.value;\n        },\n\n        set(t) {\n          this.uniforms.map.value = t;\n        }\n\n      },\n      useMap: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.useMap.value;\n        },\n\n        set(t) {\n          this.uniforms.useMap.value = t;\n        }\n\n      },\n      alphaMap: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.alphaMap.value;\n        },\n\n        set(t) {\n          this.uniforms.alphaMap.value = t;\n        }\n\n      },\n      useAlphaMap: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.useAlphaMap.value;\n        },\n\n        set(t) {\n          this.uniforms.useAlphaMap.value = t;\n        }\n\n      },\n      color: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.color.value;\n        },\n\n        set(t) {\n          this.uniforms.color.value = t;\n        }\n\n      },\n      opacity: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.opacity.value;\n        },\n\n        set(t) {\n          this.uniforms.opacity.value = t;\n        }\n\n      },\n      resolution: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.resolution.value;\n        },\n\n        set(t) {\n          this.uniforms.resolution.value.copy(t);\n        }\n\n      },\n      sizeAttenuation: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.sizeAttenuation.value;\n        },\n\n        set(t) {\n          this.uniforms.sizeAttenuation.value = t;\n        }\n\n      },\n      dashArray: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.dashArray.value;\n        },\n\n        set(t) {\n          this.uniforms.dashArray.value = t, this.useDash = 0 !== t ? 1 : 0;\n        }\n\n      },\n      dashOffset: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.dashOffset.value;\n        },\n\n        set(t) {\n          this.uniforms.dashOffset.value = t;\n        }\n\n      },\n      dashRatio: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.dashRatio.value;\n        },\n\n        set(t) {\n          this.uniforms.dashRatio.value = t;\n        }\n\n      },\n      useDash: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.useDash.value;\n        },\n\n        set(t) {\n          this.uniforms.useDash.value = t;\n        }\n\n      },\n      visibility: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.visibility.value;\n        },\n\n        set(t) {\n          this.uniforms.visibility.value = t;\n        }\n\n      },\n      alphaTest: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.alphaTest.value;\n        },\n\n        set(t) {\n          this.uniforms.alphaTest.value = t;\n        }\n\n      },\n      repeat: {\n        enumerable: !0,\n\n        get() {\n          return this.uniforms.repeat.value;\n        },\n\n        set(t) {\n          this.uniforms.repeat.value.copy(t);\n        }\n\n      }\n    }), this.setValues(e);\n  }\n\n  copy(t) {\n    return super.copy(t), this.lineWidth = t.lineWidth, this.map = t.map, this.useMap = t.useMap, this.alphaMap = t.alphaMap, this.useAlphaMap = t.useAlphaMap, this.color.copy(t.color), this.opacity = t.opacity, this.resolution.copy(t.resolution), this.sizeAttenuation = t.sizeAttenuation, this.dashArray.copy(t.dashArray), this.dashOffset.copy(t.dashOffset), this.dashRatio.copy(t.dashRatio), this.useDash = t.useDash, this.visibility = t.visibility, this.alphaTest = t.alphaTest, this.repeat.copy(t.repeat), this;\n  }\n\n}\n\nexport { s as MeshLine, r as MeshLineMaterial, e as MeshLineRaycast };","map":null,"metadata":{},"sourceType":"module"}