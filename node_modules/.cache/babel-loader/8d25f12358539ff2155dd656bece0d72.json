{"ast":null,"code":"import { cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nexport default function Composer(props) {\n  return renderRecursive(props.children, props.components);\n}\nComposer.propTypes = {\n  children: PropTypes.func.isRequired,\n  components: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.func])).isRequired\n};\n/**\n * Recursively build up elements from props.components and accumulate `results` along the way.\n * @param {function} render\n * @param {Array.<ReactElement|Function>} remaining\n * @param {Array} [results]\n * @returns {ReactElement}\n */\n\nfunction renderRecursive(render, remaining, results) {\n  results = results || []; // Once components is exhausted, we can render out the results array.\n\n  if (!remaining[0]) {\n    return render(results);\n  } // Continue recursion for remaining items.\n  // results.concat([value]) ensures [...results, value] instead of [...results, ...value]\n\n\n  function nextRender(value) {\n    return renderRecursive(render, remaining.slice(1), results.concat([value]));\n  } // Each props.components entry is either an element or function [element factory]\n\n\n  return typeof remaining[0] === 'function' ? // When it is a function, produce an element by invoking it with \"render component values\".\n  remaining[0]({\n    results: results,\n    render: nextRender\n  }) : // When it is an element, enhance the element's props with the render prop.\n  cloneElement(remaining[0], {\n    children: nextRender\n  });\n}","map":null,"metadata":{},"sourceType":"module"}