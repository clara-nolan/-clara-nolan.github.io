{"ast":null,"code":"import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\nconst F_Schlick = new ShaderNode(inputs => {\n  const {\n    f0,\n    f90,\n    dotVH\n  } = inputs; // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\n}); // validated\n\nconst BRDF_Lambert = new ShaderNode(inputs => {\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\n}); // validated\n\nconst getDistanceAttenuation = new ShaderNode(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\n}); // validated\n//\n// STANDARD\n//\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nconst V_GGX_SmithCorrelated = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNL,\n    dotNV\n  } = inputs;\n  const a2 = pow2(alpha);\n  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\n  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\n  return div(0.5, max(add(gv, gl), EPSILON));\n}); // validated\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneyâ€™s reparameterization\n\nconst D_GGX = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNH\n  } = inputs;\n  const a2 = pow2(alpha);\n  const denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\n\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\n}); // validated\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\n\nconst BRDF_GGX = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness\n  } = inputs;\n  const alpha = pow2(roughness); // UE4's roughness\n\n  const halfDir = normalize(add(lightDirection, positionViewDirection));\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));\n  const dotNH = saturate(dot(transformedNormalView, halfDir));\n  const dotVH = saturate(dot(positionViewDirection, halfDir));\n  const F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  const V = V_GGX_SmithCorrelated({\n    alpha,\n    dotNL,\n    dotNV\n  });\n  const D = D_GGX({\n    alpha,\n    dotNH\n  });\n  return mul(F, mul(V, D));\n}); // validated\n\nconst RE_Direct_Physical = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    lightColor,\n    directDiffuse,\n    directSpecular\n  } = inputs;\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  let irradiance = mul(dotNL, lightColor);\n  irradiance = mul(irradiance, Math.PI); // punctual light\n\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\n    diffuseColor: diffuseColor.rgb\n  })));\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\n    lightDirection,\n    f0: specularColor,\n    f90: 1,\n    roughness\n  })));\n});\nconst PhysicalLightingModel = new ShaderNode((inputs\n/*, builder*/\n) => {\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\n  RE_Direct_Physical(inputs);\n});\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };","map":null,"metadata":{},"sourceType":"module"}