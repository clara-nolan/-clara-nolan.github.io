{"ast":null,"code":"import { Quaternion, Object3D, Vector3, AnimationMixer } from 'three';\nimport { CCDIKSolver } from './CCDIKSolver.js';\nimport { MMDPhysics } from './MMDPhysics.js';\n/**\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\n * with MMD special features as IK, Grant, and Physics.\n *\n * Dependencies\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - MMDPhysics\n *  - CCDIKSolver\n *\n * TODO\n *  - more precise grant skinning support.\n */\n\nconst MMDAnimationHelper = (() => {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  function MMDAnimationHelper(params) {\n    params = params || {};\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = 'target';\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = new WeakMap();\n    this.configuration = {\n      sync: params.sync !== undefined ? params.sync : true,\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n\n    this.onBeforePhysics = () =>\n    /* mesh */\n    {}; // experimental\n\n\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n\n  MMDAnimationHelper.prototype = {\n    constructor: MMDAnimationHelper,\n\n    /**\n     * Adds an Three.js Object to helper and setups animation.\n     * The anmation durations of added objects are synched\n     * if this.configuration.sync is true.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @param {Object} params - (optional)\n     * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n     * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n     * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n     * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n     * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n     * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n     * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n     * @return {MMDAnimationHelper}\n     */\n    add: function (object, params) {\n      params = params || {};\n\n      if (object.isSkinnedMesh) {\n        this._addMesh(object, params);\n      } else if (object.isCamera) {\n        this._setupCamera(object, params);\n      } else if (object.type === 'Audio') {\n        this._setupAudio(object, params);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.add: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n\n    /**\n     * Removes an Three.js Object from helper.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @return {MMDAnimationHelper}\n     */\n    remove: function (object) {\n      if (object.isSkinnedMesh) {\n        this._removeMesh(object);\n      } else if (object.isCamera) {\n        this._clearCamera(object);\n      } else if (object.type === 'Audio') {\n        this._clearAudio(object);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.remove: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n\n    /**\n     * Updates the animation.\n     *\n     * @param {Number} delta\n     * @return {MMDAnimationHelper}\n     */\n    update: function (delta) {\n      if (this.audioManager !== null) this.audioManager.control(delta);\n\n      for (let i = 0; i < this.meshes.length; i++) {\n        this._animateMesh(this.meshes[i], delta);\n      }\n\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\n      return this;\n    },\n\n    /**\n     * Changes the pose of SkinnedMesh as VPD specifies.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @param {Object} vpd - VPD content parsed MMDParser\n     * @param {Object} params - (optional)\n     * @param {boolean} params.resetPose - Default is true.\n     * @param {boolean} params.ik - Default is true.\n     * @param {boolean} params.grant - Default is true.\n     * @return {MMDAnimationHelper}\n     */\n    pose: function (mesh, vpd, params) {\n      params = params || {};\n      if (params.resetPose !== false) mesh.pose();\n      const bones = mesh.skeleton.bones;\n      const boneParams = vpd.bones;\n      const boneNameDictionary = {};\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = i;\n      }\n\n      const vector = new Vector3();\n      const quaternion = new Quaternion();\n\n      for (let i = 0, il = boneParams.length; i < il; i++) {\n        const boneParam = boneParams[i];\n        const boneIndex = boneNameDictionary[boneParam.name];\n        if (boneIndex === undefined) continue;\n        const bone = bones[boneIndex];\n        bone.position.add(vector.fromArray(boneParam.translation));\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n      }\n\n      mesh.updateMatrixWorld(true);\n\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK); // this param is experimental\n\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n\n      return this;\n    },\n\n    /**\n     * Enabes/Disables an animation feature.\n     *\n     * @param {string} key\n     * @param {boolean} enabled\n     * @return {MMDAnimationHelper}\n     */\n    enable: function (key, enabled) {\n      if (this.enabled[key] === undefined) {\n        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);\n      }\n\n      this.enabled[key] = enabled;\n\n      if (key === 'physics') {\n        for (let i = 0, il = this.meshes.length; i < il; i++) {\n          this._optimizeIK(this.meshes[i], enabled);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Creates an GrantSolver instance.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @return {GrantSolver}\n     */\n    createGrantSolver: function (mesh) {\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n    },\n    // private methods\n    _addMesh: function (mesh, params) {\n      if (this.meshes.indexOf(mesh) >= 0) {\n        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);\n      }\n\n      this.meshes.push(mesh);\n      this.objects.set(mesh, {\n        looped: false\n      });\n\n      this._setupMeshAnimation(mesh, params.animation);\n\n      if (params.physics !== false) {\n        this._setupMeshPhysics(mesh, params);\n      }\n\n      return this;\n    },\n    _setupCamera: function (camera, params) {\n      if (this.camera === camera) {\n        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);\n      }\n\n      if (this.camera) this.clearCamera(this.camera);\n      this.camera = camera;\n      camera.add(this.cameraTarget);\n      this.objects.set(camera, {});\n\n      if (params.animation !== undefined) {\n        this._setupCameraAnimation(camera, params.animation);\n      }\n\n      return this;\n    },\n    _setupAudio: function (audio, params) {\n      if (this.audio === audio) {\n        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);\n      }\n\n      if (this.audio) this.clearAudio(this.audio);\n      this.audio = audio;\n      this.audioManager = new AudioManager(audio, params);\n      this.objects.set(this.audioManager, {\n        duration: this.audioManager.duration\n      });\n      return this;\n    },\n    _removeMesh: function (mesh) {\n      let found = false;\n      let writeIndex = 0;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        if (this.meshes[i] === mesh) {\n          this.objects.delete(mesh);\n          found = true;\n          continue;\n        }\n\n        this.meshes[writeIndex++] = this.meshes[i];\n      }\n\n      if (!found) {\n        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);\n      }\n\n      this.meshes.length = writeIndex;\n      return this;\n    },\n    _clearCamera: function (camera) {\n      if (camera !== this.camera) {\n        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);\n      }\n\n      this.camera.remove(this.cameraTarget);\n      this.objects.delete(this.camera);\n      this.camera = null;\n      return this;\n    },\n    _clearAudio: function (audio) {\n      if (audio !== this.audio) {\n        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);\n      }\n\n      this.objects.delete(this.audioManager);\n      this.audio = null;\n      this.audioManager = null;\n      return this;\n    },\n    _setupMeshAnimation: function (mesh, animation) {\n      const objects = this.objects.get(mesh);\n\n      if (animation !== undefined) {\n        const animations = Array.isArray(animation) ? animation : [animation];\n        objects.mixer = new AnimationMixer(mesh);\n\n        for (let i = 0, il = animations.length; i < il; i++) {\n          objects.mixer.clipAction(animations[i]).play();\n        } // TODO: find a workaround not to access ._clip looking like a private property\n\n\n        objects.mixer.addEventListener('loop', event => {\n          const tracks = event.action._clip.tracks;\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return;\n          objects.looped = true;\n        });\n      }\n\n      objects.ikSolver = this._createCCDIKSolver(mesh);\n      objects.grantSolver = this.createGrantSolver(mesh);\n      return this;\n    },\n    _setupCameraAnimation: function (camera, animation) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      const objects = this.objects.get(camera);\n      objects.mixer = new AnimationMixer(camera);\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n    },\n    _setupMeshPhysics: function (mesh, params) {\n      const objects = this.objects.get(mesh); // shared physics is experimental\n\n      if (params.world === undefined && this.sharedPhysics) {\n        const masterPhysics = this._getMasterPhysics();\n\n        if (masterPhysics !== null) world = masterPhysics.world; // eslint-disable-line no-undef\n      }\n\n      objects.physics = this._createMMDPhysics(mesh, params);\n\n      if (objects.mixer && params.animationWarmup !== false) {\n        this._animateMesh(mesh, 0);\n\n        objects.physics.reset();\n      }\n\n      objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60);\n\n      this._optimizeIK(mesh, true);\n    },\n    _animateMesh: function (mesh, delta) {\n      const objects = this.objects.get(mesh);\n      const mixer = objects.mixer;\n      const ikSolver = objects.ikSolver;\n      const grantSolver = objects.grantSolver;\n      const physics = objects.physics;\n      const looped = objects.looped; // alternate solution to save/restore bones but less performant?\n      //mesh.pose();\n      //this._updatePropertyMixersBuffer( mesh );\n\n      if (mixer && this.enabled.animation) {\n        this._restoreBones(mesh);\n\n        mixer.update(delta);\n\n        this._saveBones(mesh);\n\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n\n      if (looped === true && this.enabled.physics) {\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n        objects.looped = false;\n      }\n\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\n        this.onBeforePhysics(mesh);\n        physics.update(delta);\n      }\n    },\n    _animateCamera: function (camera, delta) {\n      const mixer = this.objects.get(camera).mixer;\n\n      if (mixer && this.enabled.cameraAnimation) {\n        mixer.update(delta);\n        camera.updateProjectionMatrix();\n        camera.up.set(0, 1, 0);\n        camera.up.applyQuaternion(camera.quaternion);\n        camera.lookAt(this.cameraTarget.position);\n      }\n    },\n    _optimizeIK: function (mesh, physicsEnabled) {\n      const iks = mesh.geometry.userData.MMD.iks;\n      const bones = mesh.geometry.userData.MMD.bones;\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const links = ik.links;\n\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          const link = links[j];\n\n          if (physicsEnabled === true) {\n            // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n            // because its rotation will be overriden by physics\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n          } else {\n            link.enabled = true;\n          }\n        }\n      }\n    },\n    _createCCDIKSolver: function (mesh) {\n      if (CCDIKSolver === undefined) {\n        throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.');\n      }\n\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n    },\n    _createMMDPhysics: function (mesh, params) {\n      if (MMDPhysics === undefined) {\n        throw new Error('THREE.MMDPhysics: Import MMDPhysics.');\n      }\n\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n    },\n\n    /*\n     * Detects the longest duration and then sets it to them to sync.\n     * TODO: Not to access private properties ( ._actions and ._clip )\n     */\n    _syncDuration: function () {\n      let max = 0.0;\n      const objects = this.objects;\n      const meshes = this.meshes;\n      const camera = this.camera;\n      const audioManager = this.audioManager; // get the longest duration\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        var mixer = this.objects.get(meshes[i]).mixer;\n        if (mixer === undefined) continue;\n\n        for (let j = 0; j < mixer._actions.length; j++) {\n          var clip = mixer._actions[j]._clip;\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            var clip = mixer._actions[i]._clip;\n\n            if (!objects.has(clip)) {\n              objects.set(clip, {\n                duration: clip.duration\n              });\n            }\n\n            max = Math.max(max, objects.get(clip).duration);\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        max = Math.max(max, objects.get(audioManager).duration);\n      }\n\n      max += this.configuration.afterglow; // update the duration\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var mixer = this.objects.get(this.meshes[i]).mixer;\n        if (mixer === undefined) continue;\n\n        for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n          mixer._actions[j]._clip.duration = max;\n        }\n      }\n\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            mixer._actions[i]._clip.duration = max;\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        audioManager.duration = max;\n      }\n    },\n    // workaround\n    _updatePropertyMixersBuffer: function (mesh) {\n      const mixer = this.objects.get(mesh).mixer;\n      const propertyMixers = mixer._bindings;\n      const accuIndex = mixer._accuIndex;\n\n      for (let i = 0, il = propertyMixers.length; i < il; i++) {\n        const propertyMixer = propertyMixers[i];\n        const buffer = propertyMixer.buffer;\n        const stride = propertyMixer.valueSize;\n        const offset = (accuIndex + 1) * stride;\n        propertyMixer.binding.getValue(buffer, offset);\n      }\n    },\n\n    /*\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\n     *\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n     *    Calculating IK, Grant, and Physics after mixer animation can break\n     *    the cache coherency.\n     *\n     * 2. Applying Grant two or more times without reset the posing breaks model.\n     */\n    _saveBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const bones = mesh.skeleton.bones;\n      let backupBones = objects.backupBones;\n\n      if (backupBones === undefined) {\n        backupBones = new Float32Array(bones.length * 7);\n        objects.backupBones = backupBones;\n      }\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.toArray(backupBones, i * 7);\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\n      }\n    },\n    _restoreBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const backupBones = objects.backupBones;\n      if (backupBones === undefined) return;\n      const bones = mesh.skeleton.bones;\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.fromArray(backupBones, i * 7);\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\n      }\n    },\n    // experimental\n    _getMasterPhysics: function () {\n      if (this.masterPhysics !== null) return this.masterPhysics;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        const physics = this.meshes[i].physics;\n\n        if (physics !== undefined && physics !== null) {\n          this.masterPhysics = physics;\n          return this.masterPhysics;\n        }\n      }\n\n      return null;\n    },\n    _updateSharedPhysics: function (delta) {\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n\n      const physics = this._getMasterPhysics();\n\n      if (physics === null) return;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n\n        if (p !== null && p !== undefined) {\n          p.updateRigidBodies();\n        }\n      }\n\n      physics.stepSimulation(delta);\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n\n        if (p !== null && p !== undefined) {\n          p.updateBones();\n        }\n      }\n    }\n  }; //\n\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n\n  function AudioManager(audio, params) {\n    params = params || {};\n    this.audio = audio;\n    this.elapsedTime = 0.0;\n    this.currentTime = 0.0;\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n\n  AudioManager.prototype = {\n    constructor: AudioManager,\n\n    /**\n     * @param {Number} delta\n     * @return {AudioManager}\n     */\n    control: function (delta) {\n      this.elapsed += delta;\n      this.currentTime += delta;\n      if (this._shouldStopAudio()) this.audio.stop();\n      if (this._shouldStartAudio()) this.audio.play();\n      return this;\n    },\n    // private methods\n    _shouldStartAudio: function () {\n      if (this.audio.isPlaying) return false;\n\n      while (this.currentTime >= this.duration) {\n        this.currentTime -= this.duration;\n      }\n\n      if (this.currentTime < this.delayTime) return false; // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\n\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\n      return true;\n    },\n    _shouldStopAudio: function () {\n      return this.audio.isPlaying && this.currentTime >= this.duration;\n    }\n  };\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} grants\n   */\n\n  function GrantSolver(mesh, grants) {\n    this.mesh = mesh;\n    this.grants = grants || [];\n  }\n\n  GrantSolver.prototype = {\n    constructor: GrantSolver,\n\n    /**\n     * @return {GrantSolver}\n     */\n    update: (() => {\n      const quaternion = new Quaternion();\n      return function () {\n        const bones = this.mesh.skeleton.bones;\n        const grants = this.grants;\n\n        for (let i = 0, il = grants.length; i < il; i++) {\n          const grant = grants[i];\n          const bone = bones[grant.index];\n          const parentBone = bones[grant.parentIndex];\n\n          if (grant.isLocal) {\n            // TODO: implement\n            if (grant.affectPosition) ; // TODO: implement\n\n            if (grant.affectRotation) ;\n          } else {\n            // TODO: implement\n            if (grant.affectPosition) ;\n\n            if (grant.affectRotation) {\n              quaternion.set(0, 0, 0, 1);\n              quaternion.slerp(parentBone.quaternion, grant.ratio);\n              bone.quaternion.multiply(quaternion);\n            }\n          }\n        }\n\n        return this;\n      };\n    })()\n  };\n  return MMDAnimationHelper;\n})();\n\nexport { MMDAnimationHelper };","map":null,"metadata":{},"sourceType":"module"}