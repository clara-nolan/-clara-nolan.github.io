{"ast":null,"code":"import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport { raycast, raycastFirst, shapecast, intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nconst SKIP_GENERATION = Symbol('skip tree generation');\nconst aabb = /* @__PURE__ */new Box3();\nconst aabb2 = /* @__PURE__ */new Box3();\nconst tempMatrix = /* @__PURE__ */new Matrix4();\nconst obb = /* @__PURE__ */new OrientedBox();\nconst obb2 = /* @__PURE__ */new OrientedBox();\nconst temp = /* @__PURE__ */new Vector3();\nconst temp1 = /* @__PURE__ */new Vector3();\nconst temp2 = /* @__PURE__ */new Vector3();\nconst temp3 = /* @__PURE__ */new Vector3();\nconst temp4 = /* @__PURE__ */new Vector3();\nconst tempBox = /* @__PURE__ */new Box3();\nconst trianglePool = /* @__PURE__ */new PrimitivePool(() => new ExtendedTriangle());\nexport class MeshBVH {\n  static serialize(bvh) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.isBufferGeometry) {\n      console.warn('MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.');\n      return MeshBVH.serialize(arguments[0], {\n        cloneBuffers: arguments[2] === undefined ? true : arguments[2]\n      });\n    }\n\n    options = {\n      cloneBuffers: true,\n      ...options\n    };\n    const geometry = bvh.geometry;\n    const rootData = bvh._roots;\n    const indexAttribute = geometry.getIndex();\n    let result;\n\n    if (options.cloneBuffers) {\n      result = {\n        roots: rootData.map(root => root.slice()),\n        index: indexAttribute.array.slice()\n      };\n    } else {\n      result = {\n        roots: rootData,\n        index: indexAttribute.array\n      };\n    }\n\n    return result;\n  }\n\n  static deserialize(data, geometry) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof options === 'boolean') {\n      console.warn('MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.');\n      return MeshBVH.deserialize(arguments[0], arguments[1], {\n        setIndex: arguments[2] === undefined ? true : arguments[2]\n      });\n    }\n\n    options = {\n      setIndex: true,\n      ...options\n    };\n    const {\n      index,\n      roots\n    } = data;\n    const bvh = new MeshBVH(geometry, { ...options,\n      [SKIP_GENERATION]: true\n    });\n    bvh._roots = roots;\n\n    if (options.setIndex) {\n      const indexAttribute = geometry.getIndex();\n\n      if (indexAttribute === null) {\n        const newIndex = new BufferAttribute(data.index, 1, false);\n        geometry.setIndex(newIndex);\n      } else if (indexAttribute.array !== index) {\n        indexAttribute.array.set(index);\n        indexAttribute.needsUpdate = true;\n      }\n    }\n\n    return bvh;\n  }\n\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null,\n      // undocumented options\n      // Whether to skip generating the tree. Used for deserialization.\n      [SKIP_GENERATION]: false\n    }, options);\n\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined') {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  refit() {\n    let nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n      nodeIndices = new Set(nodeIndices);\n    }\n\n    const geometry = this.geometry;\n    const indexArr = geometry.index.array;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = this._roots;\n\n    for (let i = 0, l = roots.length; i < l; i++) {\n      buffer = roots[i];\n      uint32Array = new Uint32Array(buffer);\n      uint16Array = new Uint16Array(buffer);\n      float32Array = new Float32Array(buffer);\n\n      _traverse(0, byteOffset);\n\n      byteOffset += buffer.byteLength;\n    }\n\n    function _traverse(node32Index, byteOffset) {\n      let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        let minx = Infinity;\n        let miny = Infinity;\n        let minz = Infinity;\n        let maxx = -Infinity;\n        let maxy = -Infinity;\n        let maxz = -Infinity;\n\n        for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {\n          const index = indexArr[i];\n          const x = posAttr.getX(index);\n          const y = posAttr.getY(index);\n          const z = posAttr.getZ(index);\n          if (x < minx) minx = x;\n          if (x > maxx) maxx = x;\n          if (y < miny) miny = y;\n          if (y > maxy) maxy = y;\n          if (z < minz) minz = z;\n          if (z > maxz) maxz = z;\n        }\n\n        if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n          float32Array[node32Index + 0] = minx;\n          float32Array[node32Index + 1] = miny;\n          float32Array[node32Index + 2] = minz;\n          float32Array[node32Index + 3] = maxx;\n          float32Array[node32Index + 4] = maxy;\n          float32Array[node32Index + 5] = maxz;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        const left = node32Index + 8;\n        const right = uint32Array[node32Index + 6]; // the identifying node indices provided by the shapecast function include offsets of all\n        // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n        const offsetLeft = left + byteOffset;\n        const offsetRight = right + byteOffset;\n        let forceChildren = force;\n        let includesLeft = false;\n        let includesRight = false;\n\n        if (nodeIndices) {\n          // if we see that neither the left or right child are included in the set that need to be updated\n          // then we assume that all children need to be updated.\n          if (!forceChildren) {\n            includesLeft = nodeIndices.has(offsetLeft);\n            includesRight = nodeIndices.has(offsetRight);\n            forceChildren = !includesLeft && !includesRight;\n          }\n        } else {\n          includesLeft = true;\n          includesRight = true;\n        }\n\n        const traverseLeft = forceChildren || includesLeft;\n        const traverseRight = forceChildren || includesRight;\n        let leftChange = false;\n\n        if (traverseLeft) {\n          leftChange = _traverse(left, byteOffset, forceChildren);\n        }\n\n        let rightChange = false;\n\n        if (traverseRight) {\n          rightChange = _traverse(right, byteOffset, forceChildren);\n        }\n\n        const didChange = leftChange || rightChange;\n\n        if (didChange) {\n          for (let i = 0; i < 3; i++) {\n            const lefti = left + i;\n            const righti = right + i;\n            const minLeftValue = float32Array[lefti];\n            const maxLeftValue = float32Array[lefti + 3];\n            const minRightValue = float32Array[righti];\n            const maxRightValue = float32Array[righti + 3];\n            float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n            float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n          }\n        }\n\n        return didChange;\n      }\n    }\n  }\n\n  traverse(callback) {\n    let rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const buffer = this._roots[rootIndex];\n    const uint32Array = new Uint32Array(buffer);\n    const uint16Array = new Uint16Array(buffer);\n\n    _traverse(0);\n\n    function _traverse(node32Index) {\n      let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n      } else {\n        // TODO: use node functions here\n        const left = node32Index + BYTES_PER_NODE / 4;\n        const right = uint32Array[node32Index + 6];\n        const splitAxis = uint32Array[node32Index + 7];\n        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n        if (!stopTraversal) {\n          _traverse(left, depth + 1);\n\n          _traverse(right, depth + 1);\n        }\n      }\n    }\n  }\n  /* Core Cast Functions */\n\n\n  raycast(ray) {\n    let materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const intersects = [];\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      const startCount = intersects.length;\n      setBuffer(roots[i]);\n      raycast(0, geometry, materialSide, ray, intersects);\n      clearBuffer();\n\n      if (isArrayMaterial) {\n        const materialIndex = groups[i].materialIndex;\n\n        for (let j = startCount, jl = intersects.length; j < jl; j++) {\n          intersects[j].face.materialIndex = materialIndex;\n        }\n      }\n    }\n\n    return intersects;\n  }\n\n  raycastFirst(ray) {\n    let materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    let closestResult = null;\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      setBuffer(roots[i]);\n      const result = raycastFirst(0, geometry, materialSide, ray);\n      clearBuffer();\n\n      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n        closestResult = result;\n\n        if (isArrayMaterial) {\n          result.face.materialIndex = groups[i].materialIndex;\n        }\n      }\n    }\n\n    return closestResult;\n  }\n\n  intersectsGeometry(otherGeometry, geomToMesh) {\n    const geometry = this.geometry;\n    let result = false;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n      clearBuffer();\n\n      if (result) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n    const geometry = this.geometry;\n\n    if (callbacks instanceof Function) {\n      if (_intersectsTriangleFunc) {\n        // Support the previous function signature that provided three sequential index buffer\n        // indices here.\n        const originalTriangleFunc = _intersectsTriangleFunc;\n\n        _intersectsTriangleFunc = (tri, index, contained, depth) => {\n          const i3 = index * 3;\n          return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n        };\n      }\n\n      callbacks = {\n        boundsTraverseOrder: _orderNodesFunc,\n        intersectsBounds: callbacks,\n        intersectsTriangle: _intersectsTriangleFunc,\n        intersectsRange: null\n      };\n      console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n    }\n\n    const triangle = trianglePool.getPrimitive();\n    let {\n      boundsTraverseOrder,\n      intersectsBounds,\n      intersectsRange,\n      intersectsTriangle\n    } = callbacks;\n\n    if (intersectsRange && intersectsTriangle) {\n      const originalIntersectsRange = intersectsRange;\n\n      intersectsRange = (offset, count, contained, depth, nodeIndex) => {\n        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        }\n\n        return true;\n      };\n    } else if (!intersectsRange) {\n      if (intersectsTriangle) {\n        intersectsRange = (offset, count, contained, depth) => {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        };\n      } else {\n        intersectsRange = (offset, count, contained) => {\n          return contained;\n        };\n      }\n    }\n\n    let result = false;\n    let byteOffset = 0;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n      clearBuffer();\n\n      if (result) {\n        break;\n      }\n\n      byteOffset += root.byteLength;\n    }\n\n    trianglePool.releasePrimitive(triangle);\n    return result;\n  }\n\n  bvhcast(otherBvh, matrixToLocal, callbacks) {\n    // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n    // than an approach that walks down the tree (see bvhcast.js file for more info).\n    let {\n      intersectsRanges,\n      intersectsTriangles\n    } = callbacks;\n    const indexAttr = this.geometry.index;\n    const positionAttr = this.geometry.attributes.position;\n    const otherIndexAttr = otherBvh.geometry.index;\n    const otherPositionAttr = otherBvh.geometry.attributes.position;\n    tempMatrix.copy(matrixToLocal).invert();\n    const triangle = trianglePool.getPrimitive();\n    const triangle2 = trianglePool.getPrimitive();\n\n    if (intersectsTriangles) {\n      function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n          setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n          triangle2.a.applyMatrix4(matrixToLocal);\n          triangle2.b.applyMatrix4(matrixToLocal);\n          triangle2.c.applyMatrix4(matrixToLocal);\n          triangle2.needsUpdate = true;\n\n          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n            setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n            triangle.needsUpdate = true;\n\n            if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n\n      if (intersectsRanges) {\n        const originalIntersectsRanges = intersectsRanges;\n\n        intersectsRanges = function (offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n          }\n\n          return true;\n        };\n      } else {\n        intersectsRanges = iterateOverDoubleTriangles;\n      }\n    }\n\n    otherBvh.getBoundingBox(aabb2);\n    aabb2.applyMatrix4(matrixToLocal);\n    const result = this.shapecast({\n      intersectsBounds: box => aabb2.intersectsBox(box),\n      intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box) => {\n        aabb.copy(box);\n        aabb.applyMatrix4(tempMatrix);\n        return otherBvh.shapecast({\n          intersectsBounds: box => aabb.intersectsBox(box),\n          intersectsRange: (offset2, count2, contained, depth2, nodeIndex2) => {\n            return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n          }\n        });\n      }\n    });\n    trianglePool.releasePrimitive(triangle);\n    trianglePool.releasePrimitive(triangle2);\n    return result;\n  }\n  /* Derived Cast Functions */\n\n\n  intersectsBox(box, boxToMesh) {\n    obb.set(box.min, box.max, boxToMesh);\n    obb.needsUpdate = true;\n    return this.shapecast({\n      intersectsBounds: box => obb.intersectsBox(box),\n      intersectsTriangle: tri => obb.intersectsTriangle(tri)\n    });\n  }\n\n  intersectsSphere(sphere) {\n    return this.shapecast({\n      intersectsBounds: box => sphere.intersectsBox(box),\n      intersectsTriangle: tri => tri.intersectsSphere(sphere)\n    });\n  }\n\n  closestPointToGeometry(otherGeometry, geometryToBvh) {\n    let target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n\n    if (!otherGeometry.boundingBox) {\n      otherGeometry.computeBoundingBox();\n    }\n\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = this.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = trianglePool.getPrimitive();\n    const triangle2 = trianglePool.getPrimitive();\n    let tempTarget1 = temp1;\n    let tempTargetDest1 = temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n\n    if (target2) {\n      tempTarget2 = temp3;\n      tempTargetDest2 = temp4;\n    }\n\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    tempMatrix.copy(geometryToBvh).invert();\n    obb2.matrix.copy(tempMatrix);\n    this.shapecast({\n      boundsTraverseOrder: box => {\n        return obb.distanceToBox(box);\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        if (score < closestDistance && score < maxThreshold) {\n          // if we know the triangles of this bounds will be intersected next then\n          // save the bounds to use during triangle checks.\n          if (isLeaf) {\n            obb2.min.copy(box.min);\n            obb2.max.copy(box.max);\n            obb2.needsUpdate = true;\n          }\n\n          return true;\n        }\n\n        return false;\n      },\n      intersectsRange: (offset, count) => {\n        if (otherGeometry.boundsTree) {\n          // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n          // the closest bounds in the other geometry to check.\n          return otherGeometry.boundsTree.shapecast({\n            boundsTraverseOrder: box => {\n              return obb2.distanceToBox(box);\n            },\n            intersectsBounds: (box, isLeaf, score) => {\n              return score < closestDistance && score < maxThreshold;\n            },\n            intersectsRange: (otherOffset, otherCount) => {\n              for (let i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                setTriangle(triangle2, i2, otherIndex, otherPos);\n                triangle2.a.applyMatrix4(geometryToBvh);\n                triangle2.b.applyMatrix4(geometryToBvh);\n                triangle2.c.applyMatrix4(geometryToBvh);\n                triangle2.needsUpdate = true;\n\n                for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                  setTriangle(triangle, i, index, pos);\n                  triangle.needsUpdate = true;\n                  const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                  if (dist < closestDistance) {\n                    tempTargetDest1.copy(tempTarget1);\n\n                    if (tempTargetDest2) {\n                      tempTargetDest2.copy(tempTarget2);\n                    }\n\n                    closestDistance = dist;\n                    closestDistanceTriIndex = i / 3;\n                    closestDistanceOtherTriIndex = i2 / 3;\n                  } // stop traversal if we find a point that's under the given threshold\n\n\n                  if (dist < minThreshold) {\n                    return true;\n                  }\n                }\n              }\n            }\n          });\n        } else {\n          // If no bounds tree then we'll just check every triangle.\n          const triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n          for (let i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, otherIndex, otherPos);\n            triangle2.a.applyMatrix4(geometryToBvh);\n            triangle2.b.applyMatrix4(geometryToBvh);\n            triangle2.c.applyMatrix4(geometryToBvh);\n            triangle2.needsUpdate = true;\n\n            for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n              setTriangle(triangle, i, index, pos);\n              triangle.needsUpdate = true;\n              const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n              if (dist < closestDistance) {\n                tempTargetDest1.copy(tempTarget1);\n\n                if (tempTargetDest2) {\n                  tempTargetDest2.copy(tempTarget2);\n                }\n\n                closestDistance = dist;\n                closestDistanceTriIndex = i / 3;\n                closestDistanceOtherTriIndex = i2 / 3;\n              } // stop traversal if we find a point that's under the given threshold\n\n\n              if (dist < minThreshold) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    });\n    trianglePool.releasePrimitive(triangle);\n    trianglePool.releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n\n    if (target2) {\n      if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n      target2.point.applyMatrix4(tempMatrix);\n      tempTargetDest1.applyMatrix4(tempMatrix);\n      target2.distance = tempTargetDest1.sub(target2.point).length();\n      target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n\n    return target1;\n  }\n\n  closestPointToPoint(point) {\n    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    this.shapecast({\n      boundsTraverseOrder: box => {\n        temp.copy(point).clamp(box.min, box.max);\n        return temp.distanceToSquared(point);\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        return score < closestDistanceSq && score < maxThresholdSq;\n      },\n      intersectsTriangle: (tri, triIndex) => {\n        tri.closestPointToPoint(point, temp);\n        const distSq = point.distanceToSquared(temp);\n\n        if (distSq < closestDistanceSq) {\n          temp1.copy(temp);\n          closestDistanceSq = distSq;\n          closestDistanceTriIndex = triIndex;\n        }\n\n        if (distSq < minThresholdSq) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    });\n    if (closestDistanceSq === Infinity) return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n  }\n\n  getBoundingBox(target) {\n    target.makeEmpty();\n    const roots = this._roots;\n    roots.forEach(buffer => {\n      arrayToBox(0, new Float32Array(buffer), tempBox);\n      target.union(tempBox);\n    });\n    return target;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}