{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from 'three';\n\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.littleEndian = true;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, url));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n\n      do {\n        ctrl = inData[inPtr++];\n\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n          if (inPtr >= inLength) throw new Error('Invalid compressed data');\n\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          }\n\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n          if (ref < 0) throw new Error('Invalid compressed data');\n          if (ref >= outPtr) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n\n      return outData;\n    }\n\n    function parseHeader(data) {\n      const PCDheader = {};\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n      PCDheader.data = result2[1];\n      PCDheader.headerLen = result2[0].length + result1;\n      PCDheader.str = data.substr(0, PCDheader.headerLen); // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, ''); // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str); // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader.count = [];\n\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1);\n        }\n      }\n\n      PCDheader.offset = {};\n      let sizeSum = 0;\n\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i;\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum;\n          sizeSum += PCDheader.size[i] * PCDheader.count[i];\n        }\n      } // for binary only\n\n\n      PCDheader.rowSize = sizeSum;\n      return PCDheader;\n    }\n\n    const textData = LoaderUtils.decodeText(new Uint8Array(data)); // parse header (always ascii format)\n\n    const PCDheader = parseHeader(textData); // parse data\n\n    const position = [];\n    const normal = [];\n    const color = []; // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset;\n      const pcdData = textData.substr(PCDheader.headerLen);\n      const lines = pcdData.split('\\n');\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue;\n        const line = lines[i].split(' ');\n\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n\n        if (offset.rgb !== undefined) {\n          const rgb = parseFloat(line[offset.rgb]);\n          const r = rgb >> 16 & 0x0000ff;\n          const g = rgb >> 8 & 0x0000ff;\n          const b = rgb >> 0 & 0x0000ff;\n          color.push(r / 255, g / 255, b / 255);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    } // binary-compressed\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian));\n        }\n      }\n    } // binary\n\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    } // build geometry\n\n\n    const geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere(); // build material\n\n    const material = new PointsMaterial({\n      size: 0.005\n    });\n\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 0xffffff);\n    } // build point cloud\n\n\n    const mesh = new Points(geometry, material);\n    let name = url.split('').reverse().join('');\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split('').reverse().join('');\n    mesh.name = name;\n    return mesh;\n  }\n\n}\n\nexport { PCDLoader };","map":null,"metadata":{},"sourceType":"module"}