{"ast":null,"code":"import * as React from \"react\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nfunction traverseFiber(fiber, ascending, selector) {\n  if (!fiber) return;\n  if (selector(fiber) === true) return fiber;\n  let child = ascending ? fiber.return : fiber.child;\n\n  while (child) {\n    const match = traverseFiber(child, ascending, selector);\n    if (match) return match;\n    child = child.sibling;\n  }\n}\n\nfunction wrapContext(context) {\n  try {\n    return Object.defineProperties(context, {\n      _currentRenderer: {\n        get() {\n          return null;\n        },\n\n        set() {}\n\n      },\n      _currentRenderer2: {\n        get() {\n          return null;\n        },\n\n        set() {}\n\n      }\n    });\n  } catch (_) {\n    return context;\n  }\n}\n\nconst FiberContext = wrapContext(React.createContext(null));\n\nclass FiberProvider extends React.Component {\n  render() {\n    return /* @__PURE__ */React.createElement(FiberContext.Provider, {\n      value: this._reactInternals\n    }, this.props.children);\n  }\n\n}\n\nconst {\n  ReactCurrentOwner,\n  ReactCurrentDispatcher\n} = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction useFiber() {\n  const root = React.useContext(FiberContext);\n  if (!root) throw new Error(\"its-fine: useFiber must be called within a <FiberProvider />!\");\n  const id = React.useId();\n  const fiber = React.useMemo(() => {\n    var _a;\n\n    return (_a = ReactCurrentOwner.current) != null ? _a : traverseFiber(root, false, node => {\n      let state = node.memoizedState;\n\n      while (state) {\n        if (state.memoizedState === id) return true;\n        state = state.next;\n      }\n    });\n  }, [root, id]);\n  return fiber;\n}\n\nfunction useContainer() {\n  const fiber = useFiber();\n  const root = React.useMemo(() => traverseFiber(fiber, true, node => {\n    var _a;\n\n    return ((_a = node.stateNode) == null ? void 0 : _a.containerInfo) != null;\n  }), [fiber]);\n  return root == null ? void 0 : root.stateNode.containerInfo;\n}\n\nfunction useNearestChild(type) {\n  const fiber = useFiber();\n  const childRef = React.useRef();\n  React.useLayoutEffect(() => {\n    var _a;\n\n    childRef.current = (_a = traverseFiber(fiber, false, node => typeof node.type === \"string\" && (type === void 0 || node.type === type))) == null ? void 0 : _a.stateNode;\n  }, [fiber]);\n  return childRef;\n}\n\nfunction useNearestParent(type) {\n  const fiber = useFiber();\n  const parentRef = React.useRef();\n  React.useLayoutEffect(() => {\n    var _a;\n\n    parentRef.current = (_a = traverseFiber(fiber, true, node => typeof node.type === \"string\" && (type === void 0 || node.type === type))) == null ? void 0 : _a.stateNode;\n  }, [fiber]);\n  return parentRef;\n}\n\nconst contexts = [];\nconst values = /* @__PURE__ */new WeakMap();\n\nfunction useContextBridge() {\n  var _a;\n\n  const fiber = useFiber();\n  contexts.splice(0, contexts.length);\n  traverseFiber(fiber, true, node => {\n    var _a2;\n\n    const context = (_a2 = node.type) == null ? void 0 : _a2._context;\n    if (context && context !== FiberContext) contexts.push(wrapContext(context));\n  });\n\n  for (const context of contexts) {\n    const value = (_a = ReactCurrentDispatcher.current) == null ? void 0 : _a.readContext(context);\n    values.set(context, value);\n  }\n\n  return React.useMemo(() => contexts.reduce((Prev, context) => props => /* @__PURE__ */React.createElement(Prev, null, /* @__PURE__ */React.createElement(context.Provider, __spreadProps(__spreadValues({}, props), {\n    value: values.get(context)\n  }))), props => /* @__PURE__ */React.createElement(FiberProvider, __spreadValues({}, props))), []);\n}\n\nexport { FiberProvider, traverseFiber, useContainer, useContextBridge, useFiber, useNearestChild, useNearestParent }; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}