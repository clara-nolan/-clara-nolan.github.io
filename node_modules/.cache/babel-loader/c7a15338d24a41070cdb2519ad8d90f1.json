{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/* eslint-disable no-negated-condition */\n\n\nimport { useCallback, useState } from \"react\";\n\nfunction warnIfBothValueAndIndexAreProvided(functionName, object) {\n  if (Object.values(object).every(function (value) {\n    return typeof value !== \"undefined\";\n  })) {\n    console.warn(\"\".concat(functionName, \". Expected either \").concat(Object.keys(object).join(\" or \"), \" to be provided. However all were provided\"));\n  } else if (Object.values(object).every(function (value) {\n    return typeof value === \"undefined\";\n  })) {\n    console.warn(\"\".concat(functionName, \". \").concat(Object.keys(object).join(\" , \"), \" are all undefined.\"));\n  }\n}\n/**\n * useMultiSelectableList\n * A custom hook to easily select multiple values from a list\n *\n * @param list - The list of values to select from\n * @param initialSelectIndices - The indices of the initial selections\n * @param allowUnselected - Whether or not to allow unselected values\n * @see {@link https://react-hooks.org/docs/useMultiSelectableList}\n */\n\n\nfunction useMultiSelectableList(list, initialSelectIndices, allowUnselected) {\n  if (list === void 0) {\n    list = [];\n  }\n\n  if (initialSelectIndices === void 0) {\n    initialSelectIndices = [0];\n  }\n\n  if (allowUnselected === void 0) {\n    allowUnselected = false;\n  }\n\n  var _a = useState(initialSelectIndices),\n      currentIndices = _a[0],\n      setCurrentIndices = _a[1];\n\n  var currentValues = currentIndices.map(function (index) {\n    return list[index];\n  });\n  var selection = [currentIndices, currentValues];\n\n  var updateSelections = function (_a) {\n    var indices = _a.indices,\n        values = _a.values;\n    return function () {\n      warnIfBothValueAndIndexAreProvided(\"updateSelections\", {\n        indices: indices,\n        values: values\n      });\n\n      if (typeof indices !== \"undefined\") {\n        if (!allowUnselected && indices.length === 0) {\n          console.warn(\"updateSelections failed. indices is an empty list.\");\n          return;\n        }\n\n        setCurrentIndices(indices);\n      } else if (typeof values !== \"undefined\") {\n        // eslint-disable-next-line unicorn/no-array-reduce\n        var valueIndices = list.reduce(function (accumulator, current, index) {\n          if (values.includes(current)) {\n            var array = __spreadArray(__spreadArray([], accumulator, true), [index], false);\n\n            return array;\n          }\n\n          return accumulator;\n        }, []);\n\n        if (valueIndices.length > 0) {\n          setCurrentIndices(valueIndices);\n        } else if (allowUnselected) {\n          setCurrentIndices(valueIndices);\n        } else {\n          console.warn(\"updateSelections failed. Do the values exist in the list?\");\n        }\n      }\n    };\n  };\n\n  var toggleSelectionByIndex = useCallback(function (index) {\n    var newIndices;\n\n    if (!currentIndices.includes(index)) {\n      newIndices = __spreadArray(__spreadArray([], currentIndices, true), [index], false);\n    } else {\n      newIndices = __spreadArray([], currentIndices, true);\n      var indexOfIndex = currentIndices.indexOf(index);\n\n      if (indexOfIndex !== -1) {\n        newIndices.splice(indexOfIndex, 1);\n      }\n    }\n\n    if (newIndices.length > 0) {\n      setCurrentIndices(newIndices);\n    } else if (allowUnselected) {\n      setCurrentIndices(newIndices);\n    } else {\n      console.warn(\"toggleSelection failed. Do the values exist in the list?\");\n    }\n  }, [allowUnselected, currentIndices]);\n  var toggleSelection = useCallback(function (_a) {\n    var index = _a.index,\n        value = _a.value;\n    return function () {\n      warnIfBothValueAndIndexAreProvided(\"toggleSelection\", {\n        index: index,\n        value: value\n      });\n\n      if (typeof index !== \"undefined\") {\n        toggleSelectionByIndex(index);\n      } else if (typeof value !== \"undefined\") {\n        var valueIndex = list.indexOf(value);\n\n        if (valueIndex > -1) {\n          toggleSelectionByIndex(valueIndex);\n        }\n      }\n    };\n  }, [list, toggleSelectionByIndex]);\n  var matchSelection = useCallback(function (_a) {\n    var index = _a.index,\n        value = _a.value;\n    warnIfBothValueAndIndexAreProvided(\"matchSelection\", {\n      index: index,\n      value: value\n    });\n\n    if (typeof index !== \"undefined\") {\n      return currentIndices.includes(index);\n    } else if (typeof value !== \"undefined\") {\n      return currentValues.includes(value);\n    }\n\n    return false;\n  }, [currentIndices, currentValues]);\n  var controls = {\n    matchSelection: matchSelection,\n    toggleSelection: toggleSelection,\n    updateSelections: updateSelections\n  };\n  return [selection, controls];\n}\n\nexport { useMultiSelectableList };","map":null,"metadata":{},"sourceType":"module"}