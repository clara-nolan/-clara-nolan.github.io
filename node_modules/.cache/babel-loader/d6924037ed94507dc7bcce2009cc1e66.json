{"ast":null,"code":"import { DataTexture, FloatType, UnsignedIntType, RGBAFormat, RGIntegerFormat, NearestFilter } from 'three';\nimport { FloatVertexAttributeTexture, UIntVertexAttributeTexture } from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, RIGHT_NODE, OFFSET, SPLIT_AXIS } from '../core/nodeBufferFunctions.js';\n\nfunction bvhToTextures(bvh, boundsTexture, contentsTexture) {\n  const roots = bvh._roots;\n\n  if (roots.length !== 1) {\n    throw new Error('MeshBVHUniformStruct: Multi-root BVHs not supported.');\n  }\n\n  const root = roots[0];\n  const uint16Array = new Uint16Array(root);\n  const uint32Array = new Uint32Array(root);\n  const float32Array = new Float32Array(root); // Both bounds need two elements per node so compute the height so it's twice as long as\n  // the width so we can expand the row by two and still have a square texture\n\n  const nodeCount = root.byteLength / BYTES_PER_NODE;\n  const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n  const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n  const contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n  const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n\n  for (let i = 0; i < nodeCount; i++) {\n    const nodeIndex32 = i * BYTES_PER_NODE / 4;\n    const nodeIndex16 = nodeIndex32 * 2;\n    const boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);\n\n    for (let b = 0; b < 3; b++) {\n      boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n      boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n    }\n\n    if (IS_LEAF(nodeIndex16, uint16Array)) {\n      const count = COUNT(nodeIndex16, uint16Array);\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const mergedLeafCount = 0xffff0000 | count;\n      contentsArray[i * 2 + 0] = mergedLeafCount;\n      contentsArray[i * 2 + 1] = offset;\n    } else {\n      const rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array) / BYTES_PER_NODE;\n      const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n      contentsArray[i * 2 + 0] = splitAxis;\n      contentsArray[i * 2 + 1] = rightIndex;\n    }\n  }\n\n  boundsTexture.image.data = boundsArray;\n  boundsTexture.image.width = boundsDimension;\n  boundsTexture.image.height = boundsDimension;\n  boundsTexture.format = RGBAFormat;\n  boundsTexture.type = FloatType;\n  boundsTexture.internalFormat = 'RGBA32F';\n  boundsTexture.minFilter = NearestFilter;\n  boundsTexture.magFilter = NearestFilter;\n  boundsTexture.generateMipmaps = false;\n  boundsTexture.needsUpdate = true;\n  boundsTexture.dispose();\n  contentsTexture.image.data = contentsArray;\n  contentsTexture.image.width = contentsDimension;\n  contentsTexture.image.height = contentsDimension;\n  contentsTexture.format = RGIntegerFormat;\n  contentsTexture.type = UnsignedIntType;\n  contentsTexture.internalFormat = 'RG32UI';\n  contentsTexture.minFilter = NearestFilter;\n  contentsTexture.magFilter = NearestFilter;\n  contentsTexture.generateMipmaps = false;\n  contentsTexture.needsUpdate = true;\n  contentsTexture.dispose();\n}\n\nexport class MeshBVHUniformStruct {\n  constructor() {\n    this.autoDispose = true;\n    this.index = new UIntVertexAttributeTexture();\n    this.position = new FloatVertexAttributeTexture();\n    this.bvhBounds = new DataTexture();\n    this.bvhContents = new DataTexture();\n    this.index.overrideItemSize = 3;\n  }\n\n  updateFrom(bvh) {\n    const {\n      geometry\n    } = bvh;\n    bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n    this.index.updateFrom(geometry.index);\n    this.position.updateFrom(geometry.attributes.position);\n  }\n\n  dispose() {\n    const {\n      index,\n      position,\n      bvhBounds,\n      bvhContents\n    } = this;\n    if (index) index.dispose();\n    if (position) position.dispose();\n    if (bvhBounds) bvhBounds.dispose();\n    if (bvhContents) bvhContents.dispose();\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}